import{Signal as t,signal as n,computed as e,effect as r}from"@preact/signals-core";import i,{version as o,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as s,useRef as u,useLayoutEffect as c,useMemo as f,useEffect as l}from"react";import{useSyncExternalStore as a}from"use-sync-external-store/shim/index.js";import m from"react/jsx-runtime";import p from"react/jsx-dev-runtime";let d=!1,b=null,g=!1,h=null;const v=new Map;function y(t){if(!t)return 1;const n=v.get(t);if(void 0!==n)return n;let e;const r=t.useCallback.toString();if(t.useReducer===t.useEffect)e=1;else if(t.useEffect===t.useImperativeHandle)e=32;else if(/Invalid/.test(r))e=2;else if(/updateCallback/.test(r)||/\[0\]/.test(r)&&/\[1\]/.test(r)){let n=t.useReducer.toString();if(/rerenderReducer/.test(n)||/return\s*\[\w+,/.test(n))e=16;else e=8}else e=4;v.set(t,e);return e}function _(){const[t]=o.split(".").map(Number);if(t>=19)throw new Error("Automatic signals tracking is not supported in React 19 and later, try the Babel plugin instead https://github.com/preactjs/signals/tree/main/packages/react-transform#signals-react-transform.");!function(){d=!0;Object.defineProperty(s.ReactCurrentDispatcher,"current",{get:()=>h,set(t){if(g){h=t;return}const n=y(h),e=y(t);h=t;if(function(t,n){if(1&t&&28&n)return!0;else if(2&t||2&n)return!1;else return!1}(n,e)){g=!0;b=I(1);g=!1}else if(function(t,n){return Boolean(28&t&&16&n)}(n,e)){var r;null==(r=b)||r.f();g=!0;b=I(1);g=!1}else if(function(t,n){return Boolean(28&t&&1&n)}(n,e)){var i;null==(i=b)||i.f();b=null}}})}();!function(){const t=m,n=p;i.createElement=k(i.createElement);n.jsx&&(n.jsx=k(n.jsx));t.jsx&&(t.jsx=k(t.jsx));n.jsxs&&(n.jsxs=k(n.jsxs));t.jsxs&&(t.jsxs=k(t.jsxs));n.jsxDEV&&(n.jsxDEV=k(n.jsxDEV));t.jsxDEV&&(t.jsxDEV=k(t.jsxDEV))}()}const j=[],S=Symbol.for("react.element"),x=()=>{};function k(n){if("function"!=typeof n)return n;else return function(e,r,...i){if("string"==typeof e&&r)for(let n in r){let e=r[n];if("children"!==n&&e instanceof t)r[n]=e.value}return n.call(n,e,r,...i)}}const w=Symbol.dispose||Symbol.for("Symbol.dispose");let B;function O(t,n){const e=n.effect.S();B=n;return P.bind(n,t,e)}function P(t,n){n();B=t}const R={o:0,effect:{s:void 0,c(){},S:()=>x,d(){}},subscribe:()=>x,getSnapshot:()=>0,S(){},f(){},[w](){}},$=Promise.prototype.then.bind(Promise.resolve());let A;function C(){if(!A)A=$(E)}function E(){var t;A=void 0;null==(t=B)||t.f()}function I(t=0){C();const n=u();if(null==n.current)n.current=function(t){let n,e,i,o=0,s=r(function(){n=this});n.c=function(){o=o+1|0;if(i)i()};return{o:t,effect:n,subscribe(t){i=t;return function(){o=o+1|0;i=void 0;s()}},getSnapshot:()=>o,S(){if(null==B){e=O(void 0,this);return}const t=B.o,n=this.o;if(0==t&&0==n||0==t&&1==n){B.f();e=O(void 0,this)}else if(1==t&&0==n||2==t&&0==n);else e=O(B,this)},f(){const t=e;e=void 0;null==t||t()},[w](){this.f()}}}(t);const e=n.current;a(e.subscribe,e.getSnapshot,e.getSnapshot);e.S();if(0===t)c(E);return e}Object.defineProperties(t.prototype,{$$typeof:{configurable:!0,value:S},type:{configurable:!0,value:function({data:t}){const n=I(1);try{return t.value}finally{n.f()}}},props:{configurable:!0,get(){return{data:this}}},ref:{configurable:!0,value:null}});function M(t){if(d)return R;else return I(t)}function useSignal(t){return f(()=>n(t),j)}function useComputed(t){const n=u(t);n.current=t;return f(()=>e(()=>n.current()),j)}function useSignalEffect(t){const n=u(t);n.current=t;l(()=>r(()=>n.current()),j)}export{I as _useSignalsImplementation,C as ensureFinalCleanup,_ as installAutoSignalTracking,useComputed,useSignal,useSignalEffect,M as useSignals,k as wrapJsx};//# sourceMappingURL=runtime.mjs.map
