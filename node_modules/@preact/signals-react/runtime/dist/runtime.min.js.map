{"version":3,"file":"runtime.min.js","sources":["../src/auto.ts","../src/index.ts"],"sourcesContent":["import {\n\t// @ts-ignore-next-line\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as ReactInternals,\n\tversion as reactVersion,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { EffectStore, wrapJsx, _useSignalsImplementation } from \"./index\";\n\nexport interface ReactDispatcher {\n\tuseRef: typeof React.useRef;\n\tuseCallback: typeof React.useCallback;\n\tuseReducer: typeof React.useReducer;\n\tuseSyncExternalStore: typeof React.useSyncExternalStore;\n\tuseEffect: typeof React.useEffect;\n\tuseImperativeHandle: typeof React.useImperativeHandle;\n}\n\n// In order for signals to work in React, we need to observe what signals a\n// component uses while rendering. To do this, we need to know when a component\n// is rendering. To do this, we watch the transition of the\n// ReactCurrentDispatcher to know when a component is rerendering.\n//\n// To track when we are entering and exiting a component render (i.e. before and\n// after React renders a component), we track how the dispatcher changes.\n// Outside of a component rendering, the dispatcher is set to an instance that\n// errors or warns when any hooks are called. This behavior is prevents hooks\n// from being used outside of components. Right before React renders a\n// component, the dispatcher is set to an instance that doesn't warn or error\n// and contains the implementations of all hooks. Right after React finishes\n// rendering a component, the dispatcher is set to the erroring one again. This\n// erroring dispatcher is called the `ContextOnlyDispatcher` in React's source.\n//\n// So, we watch the getter and setter on `ReactCurrentDispatcher.current` to\n// monitor the changes to the current ReactDispatcher. When the dispatcher\n// changes from the ContextOnlyDispatcher to a \"valid\" dispatcher, we assume we\n// are entering a component render. At this point, we setup our\n// auto-subscriptions for any signals used in the component. We do this by\n// creating an Signal effect and manually starting the Signal effect. We use\n// `useSyncExternalStore` to trigger rerenders on the component when any signals\n// it uses changes.\n//\n// When the dispatcher changes from a valid dispatcher back to the\n// ContextOnlyDispatcher, we assume we are exiting a component render. At this\n// point we stop the effect.\n//\n// Some additional complexities to be aware of:\n// - If a component calls `setState` while rendering, React will re-render the\n//   component immediately. Before triggering the re-render, React will change\n//   the dispatcher to the HooksDispatcherOnRerender. When we transition to this\n//   rerendering adapter, we need to re-trigger our hooks to keep the order of\n//   hooks the same for every render of a component.\n//\n// - In development, useReducer, useState, and useMemo change the dispatcher to\n//   a different warning dispatcher (not ContextOnlyDispatcher) before invoking\n//   the reducer and resets it right after.\n//\n//   The useSyncExternalStore shim will use some of these hooks when we invoke\n//   it while entering a component render. We need to prevent this dispatcher\n//   change caused by these hooks from re-triggering our entering logic (it\n//   would cause an infinite loop if we did not). We do this by using a lock to\n//   prevent the setter from running while we are in the setter.\n//\n//   When a Component's function body invokes useReducer, useState, or useMemo,\n//   this change in dispatcher should not signal that we are entering or exiting\n//   a component render. We ignore this change by detecting these dispatchers as\n//   different from ContextOnlyDispatcher and other valid dispatchers.\n//\n// - The `use` hook will change the dispatcher to from a valid update dispatcher\n//   to a valid mount dispatcher in some cases. Similarly to useReducer\n//   mentioned above, we should not signal that we are exiting a component\n//   during this change. Because these other valid dispatchers do not pass the\n//   ContextOnlyDispatcher check, they do not affect our logic.\n//\n// - When server rendering, React does not change the dispatcher before and\n//   after each component render. It sets it once for before the first render\n//   and once for after the last render. This means that we will not be able to\n//   detect when we are entering or exiting a component render. This is fine\n//   because we don't need to detect this for server rendering. A component\n//   can't trigger async rerenders in SSR so we don't need to track signals.\n//\n//   If a component updates a signal value while rendering during SSR, we will\n//   not rerender the component because the signal value will synchronously\n//   change so all reads of the signal further down the tree will see the new\n//   value.\n\n/*\nBelow is a state machine definition for transitions between the various\ndispatchers in React's prod build. (It does not include dev time warning\ndispatchers which are just always ignored).\n\nENTER and EXIT suffixes indicates whether this ReactCurrentDispatcher transition\nsignals we are entering or exiting a component render, or if it doesn't signal a\nchange in the component rendering lifecyle (NOOP).\n\n```js\n// Paste this into https://stately.ai/viz to visualize the state machine.\nimport { createMachine } from \"xstate\";\n\n// ENTER, EXIT, NOOP suffixes indicates whether this ReactCurrentDispatcher\n// transition signals we are entering or exiting a component render, or\n// if it doesn't signal a change in the component rendering lifecyle (NOOP).\n\nconst dispatcherMachinePROD = createMachine({\n\tid: \"ReactCurrentDispatcher_PROD\",\n\tinitial: \"null\",\n\tstates: {\n\t\tnull: {\n\t\t\ton: {\n\t\t\t\tpushDispatcher: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tContextOnlyDispatcher: {\n\t\t\ton: {\n\t\t\t\trenderWithHooks_Mount_ENTER: \"HooksDispatcherOnMount\",\n\t\t\t\trenderWithHooks_Update_ENTER: \"HooksDispatcherOnUpdate\",\n\t\t\t\tpushDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t\tpopDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnMount: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnUpdate: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tuse_ResumeSuspensedMount_NOOP: \"HooksDispatcherOnMount\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnRerender: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t},\n});\n```\n*/\n\nexport let isAutoSignalTrackingInstalled = false;\n\nlet store: EffectStore | null = null;\nlet lock = false;\nlet currentDispatcher: ReactDispatcher | null = null;\n\nfunction installCurrentDispatcherHook() {\n\tisAutoSignalTrackingInstalled = true;\n\n\tObject.defineProperty(ReactInternals.ReactCurrentDispatcher, \"current\", {\n\t\tget() {\n\t\t\treturn currentDispatcher;\n\t\t},\n\t\tset(nextDispatcher: ReactDispatcher) {\n\t\t\tif (lock) {\n\t\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentDispatcherType = getDispatcherType(currentDispatcher);\n\t\t\tconst nextDispatcherType = getDispatcherType(nextDispatcher);\n\n\t\t\t// Update the current dispatcher now so the hooks inside of the\n\t\t\t// useSyncExternalStore shim get the right dispatcher.\n\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\tif (\n\t\t\t\tisEnteringComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tlock = true;\n\t\t\t\tstore = _useSignalsImplementation(1);\n\t\t\t\tlock = false;\n\t\t\t} else if (\n\t\t\t\tisRestartingComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tstore?.f();\n\t\t\t\tlock = true;\n\t\t\t\tstore = _useSignalsImplementation(1);\n\t\t\t\tlock = false;\n\t\t\t} else if (\n\t\t\t\tisExitingComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tstore?.f();\n\t\t\t\tstore = null;\n\t\t\t}\n\t\t},\n\t});\n}\n\ntype DispatcherType = number;\nconst ContextOnlyDispatcherType = 1 << 0;\nconst WarningDispatcherType = 1 << 1;\nconst MountDispatcherType = 1 << 2;\nconst UpdateDispatcherType = 1 << 3;\nconst RerenderDispatcherType = 1 << 4;\nconst ServerDispatcherType = 1 << 5;\nconst BrowserClientDispatcherType =\n\tMountDispatcherType | UpdateDispatcherType | RerenderDispatcherType;\n\nconst dispatcherTypeCache = new Map<ReactDispatcher, DispatcherType>();\nfunction getDispatcherType(dispatcher: ReactDispatcher | null): DispatcherType {\n\t// Treat null the same as the ContextOnlyDispatcher.\n\tif (!dispatcher) return ContextOnlyDispatcherType;\n\n\tconst cached = dispatcherTypeCache.get(dispatcher);\n\tif (cached !== undefined) return cached;\n\n\t// The ContextOnlyDispatcher sets all the hook implementations to a function\n\t// that takes no arguments and throws and error. This dispatcher is the only\n\t// dispatcher where useReducer and useEffect will have the same\n\t// implementation.\n\tlet type: DispatcherType;\n\tconst useCallbackImpl = dispatcher.useCallback.toString();\n\tif (dispatcher.useReducer === dispatcher.useEffect) {\n\t\ttype = ContextOnlyDispatcherType;\n\n\t\t// @ts-expect-error When server rendering, useEffect and useImperativeHandle\n\t\t// are both set to noop functions and so have the same implementation.\n\t} else if (dispatcher.useEffect === dispatcher.useImperativeHandle) {\n\t\ttype = ServerDispatcherType;\n\t} else if (/Invalid/.test(useCallbackImpl)) {\n\t\t// We first check for warning dispatchers because they would also pass some\n\t\t// of the checks below.\n\t\ttype = WarningDispatcherType;\n\t} else if (\n\t\t// The development mount dispatcher invokes a function called\n\t\t// `mountCallback` whereas the development update/re-render dispatcher\n\t\t// invokes a function called `updateCallback`. Use that difference to\n\t\t// determine if we are in a mount or update-like dispatcher in development.\n\t\t// The production mount dispatcher defines an array of the form [callback,\n\t\t// deps] whereas update/re-render dispatchers read the array using array\n\t\t// indices (e.g. `[0]` and `[1]`). Use those differences to determine if we\n\t\t// are in a mount or update-like dispatcher in production.\n\t\t/updateCallback/.test(useCallbackImpl) ||\n\t\t(/\\[0\\]/.test(useCallbackImpl) && /\\[1\\]/.test(useCallbackImpl))\n\t) {\n\t\t// The update and rerender dispatchers have different implementations for\n\t\t// useReducer. We'll check it's implementation to determine if this is the\n\t\t// rerender or update dispatcher.\n\t\tlet useReducerImpl = dispatcher.useReducer.toString();\n\t\tif (\n\t\t\t// The development rerender dispatcher invokes a function called\n\t\t\t// `rerenderReducer` whereas the update dispatcher invokes a function\n\t\t\t// called `updateReducer`. The production rerender dispatcher returns an\n\t\t\t// array of the form `[state, dispatch]` whereas the update dispatcher\n\t\t\t// returns an array of `[fiber.memoizedState, dispatch]` so we check the\n\t\t\t// return statement in the implementation of useReducer to differentiate\n\t\t\t// between the two.\n\t\t\t/rerenderReducer/.test(useReducerImpl) ||\n\t\t\t/return\\s*\\[\\w+,/.test(useReducerImpl)\n\t\t) {\n\t\t\ttype = RerenderDispatcherType;\n\t\t} else {\n\t\t\ttype = UpdateDispatcherType;\n\t\t}\n\t} else {\n\t\ttype = MountDispatcherType;\n\t}\n\n\tdispatcherTypeCache.set(dispatcher, type);\n\treturn type;\n}\n\nfunction isEnteringComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\tif (\n\t\tcurrentDispatcherType & ContextOnlyDispatcherType &&\n\t\tnextDispatcherType & BrowserClientDispatcherType\n\t) {\n\t\t// ## Mount or update (ContextOnlyDispatcher -> ValidDispatcher (Mount or Update))\n\t\t//\n\t\t// If the current dispatcher is the ContextOnlyDispatcher and the next\n\t\t// dispatcher is a valid dispatcher, we are entering a component render.\n\t\treturn true;\n\t} else if (\n\t\tcurrentDispatcherType & WarningDispatcherType ||\n\t\tnextDispatcherType & WarningDispatcherType\n\t) {\n\t\t// ## Warning dispatcher\n\t\t//\n\t\t// If the current dispatcher or next dispatcher is an warning dispatcher,\n\t\t// we are not entering a component render. The current warning dispatchers\n\t\t// are used to warn when hooks are nested improperly and do not indicate\n\t\t// entering a new component render.\n\t\treturn false;\n\t} else {\n\t\t// ## Resuming suspended mount edge case (Update -> Mount)\n\t\t//\n\t\t// If we are transitioning from the update dispatcher to the mount\n\t\t// dispatcher, then this component is using the `use` hook and is resuming\n\t\t// from a mount. We should not re-invoke our hooks in this situation since\n\t\t// we are not entering a new component render, but instead continuing a\n\t\t// previous render.\n\t\t//\n\t\t// ## Other transitions\n\t\t//\n\t\t// For example, Mount -> Mount, Update -> Update, Mount -> Update, any\n\t\t// transition in and out of invalid dispatchers.\n\t\t//\n\t\t// There is no known transition for the following transitions so we default\n\t\t// to not triggering a re-enter of the component.\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnMount\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnUpdate\n\t\t// - HooksDispatcherOnUpdate -> HooksDispatcherOnUpdate\n\t\treturn false;\n\t}\n}\n\nfunction isRestartingComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\t// A transition from a valid browser dispatcher into the rerender dispatcher\n\t// is the restart of a component render, so we should end the current\n\t// component effect and re-invoke our hooks. Details below.\n\t//\n\t// ## In-place rerendering (e.g. Mount -> Rerender)\n\t//\n\t// If we are transitioning from the mount, update, or rerender dispatcher to\n\t// the rerender dispatcher (e.g. HooksDispatcherOnMount to\n\t// HooksDispatcherOnRerender), then this component is rerendering due to\n\t// calling setState inside of its function body. We are re-entering a\n\t// component's render method and so we should re-invoke our hooks.\n\n\treturn Boolean(\n\t\tcurrentDispatcherType & BrowserClientDispatcherType &&\n\t\t\tnextDispatcherType & RerenderDispatcherType\n\t);\n}\n\n/**\n * We are exiting a component render if the current dispatcher is a valid\n * dispatcher and the next dispatcher is the ContextOnlyDispatcher.\n */\nfunction isExitingComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\treturn Boolean(\n\t\tcurrentDispatcherType & BrowserClientDispatcherType &&\n\t\t\tnextDispatcherType & ContextOnlyDispatcherType\n\t);\n}\n\ninterface JsxRuntimeModule {\n\tjsx?(type: any, ...rest: any[]): unknown;\n\tjsxs?(type: any, ...rest: any[]): unknown;\n\tjsxDEV?(type: any, ...rest: any[]): unknown;\n}\n\nexport function installJSXHooks() {\n\tconst JsxPro: JsxRuntimeModule = jsxRuntime;\n\tconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n\t/**\n\t * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n\t * so we need to wrap it regardless.\n\t *\n\t * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n\t * include both, so one of them will be set with `undefined` values.\n\t */\n\tReact.createElement = wrapJsx(React.createElement);\n\tJsxDev.jsx && /*   */ (JsxDev.jsx = wrapJsx(JsxDev.jsx));\n\tJsxPro.jsx && /*   */ (JsxPro.jsx = wrapJsx(JsxPro.jsx));\n\tJsxDev.jsxs && /*  */ (JsxDev.jsxs = wrapJsx(JsxDev.jsxs));\n\tJsxPro.jsxs && /*  */ (JsxPro.jsxs = wrapJsx(JsxPro.jsxs));\n\tJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = wrapJsx(JsxDev.jsxDEV));\n\tJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = wrapJsx(JsxPro.jsxDEV));\n}\n\nexport function installAutoSignalTracking() {\n\tconst [major] = reactVersion.split(\".\").map(Number);\n\tif (major >= 19) {\n\t\tthrow new Error(\n\t\t\t\"Automatic signals tracking is not supported in React 19 and later, try the Babel plugin instead https://github.com/preactjs/signals/tree/main/packages/react-transform#signals-react-transform.\"\n\t\t);\n\t}\n\tinstallCurrentDispatcherHook();\n\tinstallJSXHooks();\n}\n","import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n} from \"@preact/signals-core\";\nimport { useRef, useMemo, useEffect, useLayoutEffect } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { isAutoSignalTrackingInstalled } from \"./auto\";\n\nexport { installAutoSignalTracking } from \"./auto\";\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst noop = () => {};\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tstoreRef.current = createEffectStore(_usage);\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\tif (isAutoSignalTrackingInstalled) return emptyEffectStore;\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)): void {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, Empty);\n}\n"],"names":["g","f","exports","module","require","define","amd","globalThis","self","reactSignalsRuntime","preactSignalsCore","react","index_js","jsxRuntime","jsxRuntimeDev","this","signalsCore","React","_interopDefaultLegacy","e","default","React__default","jsxRuntime__default","jsxRuntimeDev__default","isAutoSignalTrackingInstalled","store","lock","currentDispatcher","dispatcherTypeCache","Map","getDispatcherType","dispatcher","type","cached","get","undefined","useCallbackImpl","useCallback","toString","useReducer","useEffect","useImperativeHandle","test","useReducerImpl","set","Empty","ReactElemType","Symbol","noop","wrapJsx","jsx","props","i","v","Signal","value","call","apply","concat","slice","arguments","currentStore","symDispose","dispose","startComponentEffect","prevStore","nextStore","endEffect","effect","_start","finishComponentEffect","bind","_ref2","finalCleanup","emptyEffectStore","_usage","_sources","_callback","_dispose","subscribe","getSnapshot","_queueMicroTask","Promise","prototype","then","resolve","ensureFinalCleanup","cleanupTrailingStore","_currentStore","_useSignalsImplementation","storeRef","useRef","current","_ref","effectInstance","onChangeNotifyReact","version","unsubscribe","onStoreChange","prevUsage","thisUsage","end","createEffectStore","useSyncExternalStore","useLayoutEffect","Object","defineProperties","$$typeof","configurable","_ref3","data","ref","installAutoSignalTracking","reactVersion","split","map","Number","Error","defineProperty","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","nextDispatcher","currentDispatcherType","nextDispatcherType","MountDispatcherType","isEnteringComponentRender","Boolean","isRestartingComponentRender","_store","isExitingComponentRender","_store2","installCurrentDispatcherHook","JsxPro","JsxDev","createElement","jsxs","jsxDEV","installJSXHooks","useComputed","compute","$compute","useMemo","computed","useSignal","signal","useSignalEffect","cb","callback","useSignals","usage"],"mappings":"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"}