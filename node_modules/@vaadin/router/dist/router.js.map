{
  "version": 3,
  "sources": ["../src/router.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/consistent-return */\r\nimport { compile } from 'path-to-regexp';\r\nimport type { EmptyObject, Writable } from 'type-fest';\r\nimport generateUrls from './resolver/generateUrls.js';\r\nimport Resolver from './resolver/resolver.js';\r\nimport './router-config.js';\r\nimport { getNotFoundError, isFunction, isObject, isString, log, notFoundResult } from './resolver/utils.js';\r\nimport animate from './transitions/animate.js';\r\nimport { DEFAULT_TRIGGERS, setNavigationTriggers } from './triggers/navigation.js';\r\nimport type {\r\n  ActionResult,\r\n  AnyObject,\r\n  Commands,\r\n  ChainItem,\r\n  ContextExtension,\r\n  EmptyCommands,\r\n  NavigationTrigger,\r\n  Params,\r\n  PreventAndRedirectCommands,\r\n  PreventCommands,\r\n  PreventResult,\r\n  RedirectContextInfo,\r\n  RedirectResult,\r\n  ResolveContext,\r\n  Route,\r\n  RouteContext,\r\n  RouteExtension,\r\n  RouterLocation,\r\n  WebComponentInterface,\r\n  RouterOptions,\r\n  ActionValue,\r\n  NextResult,\r\n} from './types.js';\r\nimport {\r\n  amend,\r\n  copyContextWithoutNext,\r\n  createLocation,\r\n  createRedirect,\r\n  ensureRoutes,\r\n  fireRouterEvent,\r\n  getMatchedPath,\r\n  getPathnameForRouter,\r\n  logValue,\r\n  maybeCall,\r\n  processNewChildren,\r\n  renderElement,\r\n} from './utils.js';\r\n\r\nconst MAX_REDIRECT_COUNT = 256;\r\n\r\nfunction prevent(): PreventResult {\r\n  return { cancel: true };\r\n}\r\n\r\nconst rootContext: RouteContext = {\r\n  __renderId: -1,\r\n  params: {},\r\n  route: {\r\n    __synthetic: true,\r\n    children: [],\r\n    path: '',\r\n    action() {\r\n      return undefined;\r\n    },\r\n  },\r\n  pathname: '',\r\n  // eslint-disable-next-line @typescript-eslint/require-await\r\n  async next() {\r\n    return notFoundResult;\r\n  },\r\n};\r\n\r\n/**\r\n * A simple client-side router for single-page applications. It uses\r\n * express-style middleware and has a first-class support for Web Components and\r\n * lazy-loading. Works great in Polymer and non-Polymer apps.\r\n *\r\n * Use `new Router(outlet, options)` to create a new Router instance.\r\n *\r\n * * The `outlet` parameter is a reference to the DOM node to render\r\n *   the content into.\r\n *\r\n * * The `options` parameter is an optional object with options. The following\r\n *   keys are supported:\r\n *   * `baseUrl` \u2014 the initial value for [\r\n *     the `baseUrl` property\r\n *   ](#/classes/Router#property-baseUrl)\r\n *\r\n * The Router instance is automatically subscribed to navigation events\r\n * on `window`.\r\n *\r\n * See [Live Examples](#/classes/Router/demos/demo/index.html) for the detailed usage demo and code snippets.\r\n *\r\n * See also detailed API docs for the following methods, for the advanced usage:\r\n *\r\n * * [setOutlet](#/classes/Router#method-setOutlet) \u2013 should be used to configure the outlet.\r\n * * [setTriggers](#/classes/Router#method-setTriggers) \u2013 should be used to configure the navigation events.\r\n * * [setRoutes](#/classes/Router#method-setRoutes) \u2013 should be used to configure the routes.\r\n *\r\n * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.\r\n */\r\nexport class Router<R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> extends Resolver<\r\n  ActionValue,\r\n  RouteExtension<R, C>,\r\n  ContextExtension<R, C>\r\n> {\r\n  /**\r\n   * Contains read-only information about the current router location:\r\n   * pathname, active routes, parameters. See the\r\n   * [Location type declaration](#/classes/RouterLocation)\r\n   * for more details.\r\n   */\r\n  location = createLocation({ resolver: this });\r\n\r\n  /**\r\n   * A promise that is settled after the current render cycle completes. If\r\n   * there is no render cycle in progress the promise is immediately settled\r\n   * with the last render cycle result.\r\n   */\r\n  ready: Promise<RouterLocation<R, C>> = Promise.resolve(this.location);\r\n\r\n  readonly #addedByRouter = new WeakSet<Element>();\r\n  readonly #createdByRouter = new WeakSet<Element>();\r\n  readonly #navigationEventHandler = this.#onNavigationEvent.bind(this);\r\n\r\n  #lastStartedRenderId = 0;\r\n  #outlet: Element | DocumentFragment | null | undefined;\r\n  private __previousContext?: RouteContext<R, C>;\r\n\r\n  #urlForName?: ReturnType<typeof generateUrls>;\r\n\r\n  #appearingContent: Element[] | null = null;\r\n  #disappearingContent: Element[] | null = null;\r\n\r\n  /**\r\n   * Creates a new Router instance with a given outlet, and\r\n   * automatically subscribes it to navigation events on the `window`.\r\n   * Using a constructor argument or a setter for outlet is equivalent:\r\n   *\r\n   * ```\r\n   * const router = new Router();\r\n   * router.setOutlet(outlet);\r\n   * ```\r\n   * @param outlet - a container to render the resolved route\r\n   * @param options - an optional object with options\r\n   */\r\n  constructor(outlet?: Element | DocumentFragment | null, options?: RouterOptions<R, C>) {\r\n    const baseElement = document.head.querySelector('base');\r\n    const baseHref = baseElement?.getAttribute('href');\r\n    super([], {\r\n      baseUrl: baseHref ? new URL(baseHref, document.URL).href.replace(/[^/]*$/u, '') : undefined,\r\n      ...options,\r\n      resolveRoute: async (context) => await this.#resolveRoute(context),\r\n    });\r\n\r\n    setNavigationTriggers(Object.values(DEFAULT_TRIGGERS));\r\n\r\n    this.setOutlet(outlet);\r\n    this.subscribe();\r\n  }\r\n\r\n  async #resolveRoute(context: RouteContext<R, C>): Promise<ActionResult | RouteContext<R, C>> {\r\n    const { route } = context;\r\n\r\n    if (isFunction(route.children)) {\r\n      let children = await route.children(copyContextWithoutNext(context));\r\n\r\n      // The route.children() callback might have re-written the\r\n      // route.children property instead of returning a value\r\n      if (!isFunction(route.children)) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        ({ children } = route);\r\n      }\r\n      processNewChildren(children, route);\r\n    }\r\n\r\n    const commands: Commands = {\r\n      component: (component: string) => {\r\n        const element = document.createElement(component);\r\n        this.#createdByRouter.add(element);\r\n        return element;\r\n      },\r\n      prevent,\r\n      redirect: (path) => createRedirect(context, path),\r\n    };\r\n\r\n    return await Promise.resolve()\r\n      .then(async () => {\r\n        if (this.#isLatestRender(context)) {\r\n          // eslint-disable-next-line @typescript-eslint/unbound-method\r\n          return await maybeCall(route.action, route, context, commands);\r\n        }\r\n      })\r\n      .then((result) => {\r\n        if (result != null && (typeof result === 'object' || typeof result === 'symbol')) {\r\n          // Actions like `() => import('my-view.js')` are not expected to\r\n          // end the resolution, despite the result is not empty. Checking\r\n          // the result with a whitelist of values that end the resolution.\r\n          if (\r\n            result instanceof HTMLElement ||\r\n            result === notFoundResult ||\r\n            (isObject(result) && 'redirect' in result)\r\n          ) {\r\n            return result;\r\n          }\r\n        }\r\n\r\n        if (isString(route.redirect)) {\r\n          return commands.redirect(route.redirect);\r\n        }\r\n      })\r\n      .then((result) => {\r\n        if (result != null) {\r\n          return result;\r\n        }\r\n        if (isString(route.component)) {\r\n          return commands.component(route.component);\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Sets the router outlet (the DOM node where the content for the current\r\n   * route is inserted). Any content pre-existing in the router outlet is\r\n   * removed at the end of each render pass.\r\n   *\r\n   * @remarks\r\n   * This method is automatically invoked first time when creating a new Router\r\n   * instance.\r\n   *\r\n   * @param outlet - the DOM node where the content for the current route is\r\n   * inserted.\r\n   */\r\n  setOutlet(outlet?: Element | DocumentFragment | null): void {\r\n    if (outlet) {\r\n      this.#ensureOutlet(outlet);\r\n    }\r\n    this.#outlet = outlet;\r\n  }\r\n\r\n  /**\r\n   * Returns the current router outlet. The initial value is `undefined`.\r\n   *\r\n   * @returns the current router outlet (or `undefined`)\r\n   */\r\n  getOutlet(): Element | DocumentFragment | null | undefined {\r\n    return this.#outlet;\r\n  }\r\n\r\n  /**\r\n   * Sets the routing config (replacing the existing one) and triggers a\r\n   * navigation event so that the router outlet is refreshed according to the\r\n   * current `window.location` and the new routing config.\r\n   *\r\n   * Each route object may have the following properties, listed here in the processing order:\r\n   * * `path` \u2013 the route path (relative to the parent route if any) in the\r\n   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths).\r\n   *\r\n   * * `children` \u2013 an array of nested routes or a function that provides this\r\n   * array at the render time. The function can be synchronous or asynchronous:\r\n   * in the latter case the render is delayed until the returned promise is\r\n   * resolved. The `children` function is executed every time when this route is\r\n   * being rendered. This allows for dynamic route structures (e.g. backend-defined),\r\n   * but it might have a performance impact as well. In order to avoid calling\r\n   * the function on subsequent renders, you can override the `children` property\r\n   * of the route object and save the calculated array there\r\n   * (via `context.route.children = [ route1, route2, ...];`).\r\n   * Parent routes are fully resolved before resolving the children. Children\r\n   * 'path' values are relative to the parent ones.\r\n   *\r\n   * * `action` \u2013 the action that is executed before the route is resolved.\r\n   * The value for this property should be a function, accepting `context`\r\n   * and `commands` parameters described below. If present, this function is\r\n   * always invoked first, disregarding of the other properties' presence.\r\n   * The action can return a result directly or within a `Promise`, which\r\n   * resolves to the result. If the action result is an `HTMLElement` instance,\r\n   * a `commands.component(name)` result, a `commands.redirect(path)` result,\r\n   * or a `context.next()` result, the current route resolution is finished,\r\n   * and other route config properties are ignored.\r\n   * See also **Route Actions** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * * `redirect` \u2013 other route's path to redirect to. Passes all route parameters to the redirect target.\r\n   * The target route should also be defined.\r\n   * See also **Redirects** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * * `component` \u2013 the tag name of the Web Component to resolve the route to.\r\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\r\n   * If route contains the `component` property (or an action that return a component)\r\n   * and its child route also contains the `component` property, child route's component\r\n   * will be rendered as a light dom child of a parent component.\r\n   *\r\n   * * `name` \u2013 the string name of the route to use in the\r\n   * [`router.urlForName(name, params)`](#/classes/Router#method-urlForName)\r\n   * navigation helper method.\r\n   *\r\n   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the\r\n   * callback through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow\r\n   * function because arrow functions do not have their own `this` reference.\r\n   *\r\n   * `context` object that is passed to `action` function holds the following properties:\r\n   * * `context.pathname` \u2013 string with the pathname being resolved\r\n   *\r\n   * * `context.search` \u2013 search query string\r\n   *\r\n   * * `context.hash` \u2013 hash string\r\n   *\r\n   * * `context.params` \u2013 object with route parameters\r\n   *\r\n   * * `context.route` \u2013 object that holds the route that is currently being rendered.\r\n   *\r\n   * * `context.next()` \u2013 function for asynchronously getting the next route\r\n   * contents from the resolution chain (if any)\r\n   *\r\n   * `commands` object that is passed to `action` function has\r\n   * the following methods:\r\n   *\r\n   * * `commands.redirect(path)` \u2013 function that creates a redirect data\r\n   * for the path specified.\r\n   *\r\n   * * `commands.component(component)` \u2013 function that creates a new HTMLElement\r\n   * with current context. Note: the component created by this function is reused if visiting the same path twice in\r\n   * row.\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   * @param skipRender - configure the router but skip rendering the\r\n   *     route corresponding to the current `window.location` values\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n  override async setRoutes(\r\n    routes: Route<R, C> | ReadonlyArray<Route<R, C>>,\r\n    skipRender = false,\r\n  ): Promise<RouterLocation<R, C>> {\r\n    this.__previousContext = undefined;\r\n    this.#urlForName = undefined;\r\n    ensureRoutes(routes);\r\n    super.setRoutes(routes);\r\n    if (!skipRender) {\r\n      this.#onNavigationEvent();\r\n    }\r\n    return await this.ready;\r\n  }\r\n\r\n  protected override addRoutes(routes: Route<R, C> | ReadonlyArray<Route<R, C>>): ReadonlyArray<Route<R, C>> {\r\n    ensureRoutes(routes);\r\n    return super.addRoutes(routes);\r\n  }\r\n\r\n  /**\r\n   * Asynchronously resolves the given pathname and renders the resolved route\r\n   * component into the router outlet. If no router outlet is set at the time of\r\n   * calling this method, or at the time when the route resolution is completed,\r\n   * a `TypeError` is thrown.\r\n   *\r\n   * Returns a promise that is fulfilled with the router outlet DOM Element | DocumentFragment after\r\n   * the route component is created and inserted into the router outlet, or\r\n   * rejected if no route matches the given path.\r\n   *\r\n   * If another render pass is started before the previous one is completed, the\r\n   * result of the previous render pass is ignored.\r\n   *\r\n   * @param pathnameOrContext - the pathname to render or a context object with\r\n   * a `pathname` property, optional `search` and `hash` properties, and other\r\n   * properties to pass to the resolver.\r\n   * @param shouldUpdateHistory - update browser history with the rendered\r\n   * location\r\n   */\r\n  async render(\r\n    pathnameOrContext: string | ResolveContext,\r\n    shouldUpdateHistory: boolean = false,\r\n  ): Promise<RouterLocation<R, C>> {\r\n    this.#lastStartedRenderId += 1;\r\n    const renderId = this.#lastStartedRenderId;\r\n    const context = {\r\n      ...(rootContext as RouteContext<R, C>),\r\n      ...(isString(pathnameOrContext) ? { hash: '', search: '', pathname: pathnameOrContext } : pathnameOrContext),\r\n      __renderId: renderId,\r\n    } satisfies RouteContext<R, C>;\r\n\r\n    this.ready = this.#doRender(context, shouldUpdateHistory);\r\n    return await this.ready;\r\n  }\r\n\r\n  async #doRender(context: RouteContext<R, C>, shouldUpdateHistory: boolean) {\r\n    const { __renderId: renderId } = context;\r\n    try {\r\n      // Find the first route that resolves to a non-empty result\r\n      const ctx = await this.resolve(context);\r\n\r\n      // Process the result of this.resolve() and handle all special commands:\r\n      // (redirect / prevent / component). If the result is a 'component',\r\n      // then go deeper and build the entire chain of nested components matching\r\n      // the pathname. Also call all 'on before' callbacks along the way.\r\n      const contextWithChain = await this.#fullyResolveChain(ctx);\r\n\r\n      if (!this.#isLatestRender(contextWithChain)) {\r\n        return this.location;\r\n      }\r\n\r\n      const previousContext = this.__previousContext;\r\n\r\n      // Check if the render was prevented and make an early return in that case\r\n      if (contextWithChain === previousContext) {\r\n        // Replace the history with the previous context\r\n        // to make sure the URL stays the same.\r\n        this.#updateBrowserHistory(previousContext, true);\r\n        return this.location;\r\n      }\r\n\r\n      this.location = createLocation(contextWithChain);\r\n\r\n      if (shouldUpdateHistory) {\r\n        // Replace only if first render redirects, so that we don\u2019t leave\r\n        // the redirecting record in the history\r\n        this.#updateBrowserHistory(contextWithChain, renderId === 1);\r\n      }\r\n\r\n      fireRouterEvent('location-changed', {\r\n        router: this,\r\n        location: this.location,\r\n      });\r\n\r\n      // Skip detaching/re-attaching there are no render changes\r\n      if (contextWithChain.__skipAttach) {\r\n        this.#copyUnchangedElements(contextWithChain, previousContext);\r\n        this.__previousContext = contextWithChain;\r\n        return this.location;\r\n      }\r\n\r\n      this.#addAppearingContent(contextWithChain, previousContext);\r\n      const animationDone = this.#animateIfNeeded(contextWithChain);\r\n\r\n      this.#runOnAfterEnterCallbacks(contextWithChain);\r\n      this.#runOnAfterLeaveCallbacks(contextWithChain, previousContext);\r\n\r\n      await animationDone;\r\n\r\n      if (this.#isLatestRender(contextWithChain)) {\r\n        // If there is another render pass started after this one,\r\n        // the 'disappearing content' would be removed when the other\r\n        // render pass calls `this.__addAppearingContent()`\r\n        this.#removeDisappearingContent();\r\n\r\n        this.__previousContext = contextWithChain;\r\n        return this.location;\r\n      }\r\n    } catch (error: unknown) {\r\n      if (renderId === this.#lastStartedRenderId) {\r\n        if (shouldUpdateHistory) {\r\n          this.#updateBrowserHistory(this.context);\r\n        }\r\n\r\n        for (const child of this.#outlet?.children ?? []) {\r\n          child.remove();\r\n        }\r\n\r\n        this.location = createLocation(Object.assign(context, { resolver: this }));\r\n        fireRouterEvent('error', {\r\n          router: this,\r\n          error,\r\n          ...context,\r\n        });\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return this.location;\r\n  }\r\n\r\n  // `topOfTheChainContextBeforeRedirects` is a context coming from Resolver.resolve().\r\n  // It would contain a 'redirect' route or the first 'component' route that\r\n  // matched the pathname. There might be more child 'component' routes to be\r\n  // resolved and added into the chain. This method would find and add them.\r\n  // `contextBeforeRedirects` is the context containing such a child component\r\n  // route. It's only necessary when this method is called recursively (otherwise\r\n  // it's the same as the 'top of the chain' context).\r\n  //\r\n  // Apart from building the chain of child components, this method would also\r\n  // handle 'redirect' routes, call 'onBefore' callbacks and handle 'prevent'\r\n  // and 'redirect' callback results.\r\n  async #fullyResolveChain(\r\n    topOfTheChainContextBeforeRedirects: RouteContext<R, C>,\r\n    contextBeforeRedirects: RouteContext<R, C> = topOfTheChainContextBeforeRedirects,\r\n  ): Promise<RouteContext<R, C>> {\r\n    const contextAfterRedirects = await this.#findComponentContextAfterAllRedirects(contextBeforeRedirects);\r\n\r\n    const redirectsHappened = contextAfterRedirects !== contextBeforeRedirects;\r\n    const topOfTheChainContextAfterRedirects = redirectsHappened\r\n      ? contextAfterRedirects\r\n      : topOfTheChainContextBeforeRedirects;\r\n\r\n    const matchedPath = getPathnameForRouter(getMatchedPath(contextAfterRedirects.chain ?? []), this);\r\n    const isFound = matchedPath === contextAfterRedirects.pathname;\r\n\r\n    // Recursive method to try matching more child and sibling routes\r\n    const findNextContextIfAny = async (\r\n      context: RouteContext<R, C>,\r\n      parent: Route<R, C> | undefined = context.route,\r\n      prevResult?: NextResult<R, C> | null,\r\n    ): Promise<NextResult<R, C>> => {\r\n      const nextContext = await context.next(false, parent, prevResult);\r\n\r\n      if (nextContext === null || nextContext === notFoundResult) {\r\n        // Next context is not found in children, ...\r\n        if (isFound) {\r\n          // ...but original context is already fully matching - use it\r\n          return context;\r\n        } else if (parent.parent != null) {\r\n          // ...and there is no full match yet - step up to check siblings\r\n          return await findNextContextIfAny(context, parent.parent, nextContext);\r\n        }\r\n        return nextContext;\r\n      }\r\n\r\n      return nextContext;\r\n    };\r\n\r\n    const nextContext = await findNextContextIfAny(contextAfterRedirects);\r\n\r\n    if (nextContext == null || nextContext === notFoundResult) {\r\n      throw getNotFoundError<ActionValue, RouteExtension<R, C>, ContextExtension<R, C>>(\r\n        topOfTheChainContextAfterRedirects,\r\n      );\r\n    }\r\n\r\n    return nextContext !== contextAfterRedirects\r\n      ? await this.#fullyResolveChain(topOfTheChainContextAfterRedirects, nextContext)\r\n      : await this.#amendWithOnBeforeCallbacks(contextAfterRedirects);\r\n  }\r\n\r\n  async #findComponentContextAfterAllRedirects(context: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const { result } = context;\r\n    if (result instanceof HTMLElement) {\r\n      renderElement(context, result as WebComponentInterface<R, C>);\r\n      return context;\r\n    } else if (result && 'redirect' in result) {\r\n      const ctx = await this.#redirect(result.redirect, context.__redirectCount, context.__renderId);\r\n      return await this.#findComponentContextAfterAllRedirects(ctx);\r\n    }\r\n\r\n    throw result instanceof Error\r\n      ? result\r\n      : new Error(\r\n          log(\r\n            `Invalid route resolution result for path \"${context.pathname}\". ` +\r\n              `Expected redirect object or HTML element, but got: \"${logValue(result)}\". ` +\r\n              `Double check the action return value for the route.`,\r\n          ),\r\n        );\r\n  }\r\n\r\n  async #amendWithOnBeforeCallbacks(contextWithFullChain: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    return await this.#runOnBeforeCallbacks(contextWithFullChain).then(async (amendedContext) => {\r\n      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {\r\n        return amendedContext;\r\n      }\r\n      return await this.#fullyResolveChain(amendedContext);\r\n    });\r\n  }\r\n\r\n  async #runOnBeforeCallbacks(newContext: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const previousContext = (this.__previousContext ?? {}) as Partial<RouteContext<R, C>>;\r\n    const previousChain = previousContext.chain ?? [];\r\n    const newChain = newContext.chain ?? [];\r\n\r\n    let callbacks: Promise<ActionResult> = Promise.resolve(undefined);\r\n    const redirect = (pathname: string) => createRedirect(newContext, pathname) as unknown as RedirectResult;\r\n\r\n    newContext.__divergedChainIndex = 0;\r\n    newContext.__skipAttach = false;\r\n    if (previousChain.length) {\r\n      for (let i = 0; i < Math.min(previousChain.length, newChain.length); newContext.__divergedChainIndex++, i++) {\r\n        if (\r\n          previousChain[i].route !== newChain[i].route ||\r\n          (previousChain[i].path !== newChain[i].path && previousChain[i].element !== newChain[i].element) ||\r\n          !this.#isReusableElement(\r\n            previousChain[i].element as HTMLElement | undefined,\r\n            newChain[i].element as HTMLElement | undefined,\r\n          )\r\n        ) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Skip re-attaching and notifications if element and chain do not change\r\n      newContext.__skipAttach =\r\n        // Same route chain\r\n        newChain.length === previousChain.length &&\r\n        newContext.__divergedChainIndex === newChain.length &&\r\n        // Same element\r\n        this.#isReusableElement(newContext.result, previousContext.result);\r\n\r\n      if (newContext.__skipAttach) {\r\n        // execute onBeforeLeave for changed segment element when skipping attach\r\n        for (let i = newChain.length - 1; i >= 0; i--) {\r\n          callbacks = this.#runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i]);\r\n        }\r\n        // execute onBeforeEnter for changed segment element when skipping attach\r\n        for (let i = 0; i < newChain.length; i++) {\r\n          callbacks = this.#runOnBeforeEnterCallbacks(\r\n            callbacks,\r\n            newContext,\r\n            {\r\n              prevent,\r\n              redirect,\r\n            },\r\n            newChain[i],\r\n          );\r\n          previousChain[i].element!.location = createLocation(newContext, previousChain[i].route);\r\n        }\r\n      } else {\r\n        // execute onBeforeLeave when NOT skipping attach\r\n        for (let i = previousChain.length - 1; i >= newContext.__divergedChainIndex; i--) {\r\n          callbacks = this.#runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i]);\r\n        }\r\n      }\r\n    }\r\n    // execute onBeforeEnter when NOT skipping attach\r\n    if (!newContext.__skipAttach) {\r\n      for (let i = 0; i < newChain.length; i++) {\r\n        if (i < newContext.__divergedChainIndex) {\r\n          if (i < previousChain.length && previousChain[i].element) {\r\n            previousChain[i].element!.location = createLocation(newContext, previousChain[i].route);\r\n          }\r\n        } else {\r\n          callbacks = this.#runOnBeforeEnterCallbacks(\r\n            callbacks,\r\n            newContext,\r\n            {\r\n              prevent,\r\n              redirect,\r\n            },\r\n            newChain[i],\r\n          );\r\n          if (newChain[i].element) {\r\n            newChain[i].element!.location = createLocation(newContext, newChain[i].route);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return await callbacks.then(async (amendmentResult: ActionResult) => {\r\n      if (amendmentResult && isObject(amendmentResult)) {\r\n        if ('cancel' in amendmentResult && this.__previousContext) {\r\n          this.__previousContext.__renderId = newContext.__renderId;\r\n          return this.__previousContext;\r\n        }\r\n        if ('redirect' in amendmentResult) {\r\n          return await this.#redirect(amendmentResult.redirect, newContext.__redirectCount, newContext.__renderId);\r\n        }\r\n      }\r\n      return newContext;\r\n    });\r\n  }\r\n\r\n  async #runOnBeforeLeaveCallbacks(\r\n    callbacks: Promise<ActionResult>,\r\n    newContext: RouteContext<R, C>,\r\n    commands: PreventCommands,\r\n    chainElement: ChainItem<R, C>,\r\n  ): Promise<ActionResult> {\r\n    const location = createLocation(newContext);\r\n\r\n    let result: ActionResult = await callbacks;\r\n\r\n    if (this.#isLatestRender(newContext)) {\r\n      const beforeLeaveFunction = amend('onBeforeLeave', chainElement.element, location, commands, this);\r\n      result = beforeLeaveFunction(result);\r\n    }\r\n\r\n    if (!(isObject(result) && 'redirect' in result)) {\r\n      return result as ActionResult;\r\n    }\r\n  }\r\n\r\n  async #runOnBeforeEnterCallbacks(\r\n    callbacks: Promise<ActionResult>,\r\n    newContext: RouteContext<R, C>,\r\n    commands: PreventAndRedirectCommands,\r\n    chainElement: ChainItem<R, C>,\r\n  ): Promise<ActionResult> {\r\n    const location = createLocation(newContext, chainElement.route);\r\n    const result = await callbacks;\r\n\r\n    if (this.#isLatestRender(newContext)) {\r\n      const beforeEnterFunction = amend('onBeforeEnter', chainElement.element, location, commands, this);\r\n      return beforeEnterFunction(result);\r\n    }\r\n  }\r\n\r\n  #isReusableElement(element?: unknown, otherElement?: unknown): boolean {\r\n    if (element instanceof Element && otherElement instanceof Element) {\r\n      return this.#createdByRouter.has(element) && this.#createdByRouter.has(otherElement)\r\n        ? element.localName === otherElement.localName\r\n        : element === otherElement;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  #isLatestRender(context: Partial<RouteContext<R, C>>): boolean {\r\n    return context.__renderId === this.#lastStartedRenderId;\r\n  }\r\n\r\n  declare ['resolve']: (\r\n    contextOrPathname: RouteContext<R, C> | string,\r\n  ) => Promise<RouteContext<R, C> & RedirectContextInfo>;\r\n\r\n  async #redirect(\r\n    redirectData: RedirectContextInfo,\r\n    counter: number = 0,\r\n    renderId: number = 0,\r\n  ): Promise<RouteContext<R, C> & RedirectContextInfo> {\r\n    if (counter > MAX_REDIRECT_COUNT) {\r\n      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));\r\n    }\r\n\r\n    return await this.resolve({\r\n      ...(rootContext as RouteContext<R, C>),\r\n      pathname: this.urlForPath(redirectData.pathname, redirectData.params),\r\n      redirectFrom: redirectData.from,\r\n      __redirectCount: counter + 1,\r\n      __renderId: renderId,\r\n    });\r\n  }\r\n\r\n  #ensureOutlet(outlet: Element | DocumentFragment | undefined | null = this.#outlet): void {\r\n    if (!(outlet instanceof Element || outlet instanceof DocumentFragment)) {\r\n      throw new TypeError(\r\n        log(`Expected router outlet to be a valid DOM Element | DocumentFragment (but got ${outlet})`),\r\n      );\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\r\n  #updateBrowserHistory({ pathname, search = '', hash = '' }: ResolveContext, replace?: boolean): void {\r\n    if (window.location.pathname !== pathname || window.location.search !== search || window.location.hash !== hash) {\r\n      const changeState = replace ? 'replaceState' : 'pushState';\r\n      window.history[changeState](null, document.title, pathname + search + hash);\r\n      window.dispatchEvent(new PopStateEvent('popstate', { state: 'vaadin-router-ignore' }));\r\n    }\r\n  }\r\n\r\n  #copyUnchangedElements(\r\n    context: RouteContext<R, C>,\r\n    previousContext?: RouteContext<R, C>,\r\n  ): Element | DocumentFragment | null | undefined {\r\n    // Find the deepest common parent between the last and the new component\r\n    // chains. Update references for the unchanged elements in the new chain\r\n    let deepestCommonParent = this.#outlet;\r\n    for (let i = 0; i < (context.__divergedChainIndex ?? 0); i++) {\r\n      const unchangedElement = previousContext?.chain?.[i].element;\r\n      if (unchangedElement) {\r\n        if (unchangedElement.parentNode === deepestCommonParent) {\r\n          (context.chain![i] as Writable<ChainItem<R, C>>).element = unchangedElement;\r\n          deepestCommonParent = unchangedElement;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return deepestCommonParent;\r\n  }\r\n\r\n  #addAppearingContent(context: RouteContext<R, C>, previousContext?: RouteContext<R, C>): void {\r\n    this.#ensureOutlet();\r\n\r\n    // If the previous 'entering' animation has not completed yet,\r\n    // stop it and remove that content from the DOM before adding new one.\r\n    this.#removeAppearingContent();\r\n\r\n    // Copy reusable elements from the previousContext to current\r\n    const deepestCommonParent = this.#copyUnchangedElements(context, previousContext);\r\n\r\n    // Keep two lists of DOM elements:\r\n    //  - those that should be removed once the transition animation is over\r\n    //  - and those that should remain\r\n    this.#appearingContent = [];\r\n    this.#disappearingContent = Array.from(deepestCommonParent?.children ?? []).filter(\r\n      // Only remove layout content that was added by router\r\n      (e) =>\r\n        this.#addedByRouter.has(e) &&\r\n        // Do not remove the result element to avoid flickering\r\n        e !== context.result,\r\n    );\r\n\r\n    // Add new elements (starting after the deepest common parent) to the DOM.\r\n    // That way only the components that are actually different between the two\r\n    // locations are added to the DOM (and those that are common remain in the\r\n    // DOM without first removing and then adding them again).\r\n    let parentElement = deepestCommonParent;\r\n    for (let i = context.__divergedChainIndex ?? 0; i < (context.chain?.length ?? 0); i++) {\r\n      const elementToAdd = context.chain![i].element;\r\n      if (elementToAdd) {\r\n        parentElement?.appendChild(elementToAdd);\r\n        this.#addedByRouter.add(elementToAdd);\r\n        if (parentElement === deepestCommonParent) {\r\n          this.#appearingContent.push(elementToAdd);\r\n        }\r\n        parentElement = elementToAdd;\r\n      }\r\n    }\r\n  }\r\n\r\n  #removeDisappearingContent(): void {\r\n    if (this.#disappearingContent) {\r\n      for (const element of this.#disappearingContent) {\r\n        element.remove();\r\n      }\r\n    }\r\n    this.#disappearingContent = null;\r\n    this.#appearingContent = null;\r\n  }\r\n\r\n  #removeAppearingContent(): void {\r\n    if (this.#disappearingContent && this.#appearingContent) {\r\n      for (const element of this.#appearingContent) {\r\n        element.remove();\r\n      }\r\n      this.#disappearingContent = null;\r\n      this.#appearingContent = null;\r\n    }\r\n  }\r\n\r\n  #runOnAfterLeaveCallbacks(currentContext: RouteContext<R, C>, targetContext?: RouteContext<R, C>): void {\r\n    if (!targetContext?.chain || currentContext.__divergedChainIndex == null) {\r\n      return;\r\n    }\r\n\r\n    // REVERSE iteration: from Z to A\r\n    for (let i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {\r\n      if (!this.#isLatestRender(currentContext)) {\r\n        break;\r\n      }\r\n      const currentComponent = targetContext.chain[i].element;\r\n      if (!currentComponent) {\r\n        continue;\r\n      }\r\n      try {\r\n        const location = createLocation(currentContext);\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        maybeCall(currentComponent.onAfterLeave, currentComponent, location, {} as EmptyCommands, this);\r\n      } finally {\r\n        if (this.#disappearingContent?.includes(currentComponent)) {\r\n          for (const child of currentComponent.children) {\r\n            child.remove();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  #runOnAfterEnterCallbacks(currentContext: RouteContext<R, C>): void {\r\n    if (!currentContext.chain || currentContext.__divergedChainIndex == null) {\r\n      return;\r\n    }\r\n\r\n    // forward iteration: from A to Z\r\n    for (let i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {\r\n      if (!this.#isLatestRender(currentContext)) {\r\n        break;\r\n      }\r\n      const currentComponent = currentContext.chain[i].element;\r\n      if (currentComponent) {\r\n        const location = createLocation(currentContext, currentContext.chain[i].route);\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        maybeCall(currentComponent.onAfterEnter, currentComponent, location, {}, this);\r\n      }\r\n    }\r\n  }\r\n\r\n  async #animateIfNeeded(context: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const from = this.#disappearingContent?.[0];\r\n    const to = this.#appearingContent?.[0];\r\n    const promises = [];\r\n\r\n    const { chain = [] } = context;\r\n    let config;\r\n    for (let i = chain.length - 1; i >= 0; i--) {\r\n      if (chain[i].route.animate) {\r\n        config = chain[i].route.animate;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (from && to && config) {\r\n      const leave = isObject(config) && config.leave ? config.leave : 'leaving';\r\n      const enter = isObject(config) && config.enter ? config.enter : 'entering';\r\n      promises.push(animate(from, leave));\r\n      promises.push(animate(to, enter));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Subscribes this instance to navigation events on the `window`.\r\n   *\r\n   * NOTE: beware of resource leaks. For as long as a router instance is\r\n   * subscribed to navigation events, it won't be garbage collected.\r\n   */\r\n  subscribe(): void {\r\n    window.addEventListener('vaadin-router-go', this.#navigationEventHandler);\r\n  }\r\n\r\n  /**\r\n   * Removes the subscription to navigation events created in the `subscribe()`\r\n   * method.\r\n   */\r\n  unsubscribe(): void {\r\n    window.removeEventListener('vaadin-router-go', this.#navigationEventHandler);\r\n  }\r\n\r\n  #onNavigationEvent(event?: Event): void {\r\n    const { pathname, search, hash } =\r\n      event instanceof CustomEvent ? (event.detail as ResolveContext) : window.location;\r\n\r\n    if (isString(this.__normalizePathname(pathname))) {\r\n      if (event?.preventDefault) {\r\n        event.preventDefault();\r\n      }\r\n      // eslint-disable-next-line no-void\r\n      void this.render({ pathname, search, hash }, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configures what triggers Router navigation events:\r\n   *  - `POPSTATE`: popstate events on the current `window`\r\n   *  - `CLICK`: click events on `<a>` links leading to the current page\r\n   *\r\n   * This method is invoked with the pre-configured values when creating a new Router instance.\r\n   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.\r\n   *\r\n   * See the `router-config.js` for the default navigation triggers config. Based on it, you can\r\n   * create the own one and only import the triggers you need, instead of pulling in all the code,\r\n   * e.g. if you want to handle `click` differently.\r\n   *\r\n   * See also **Navigation Triggers** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * @param triggers - navigation triggers\r\n   */\r\n  static setTriggers(...triggers: readonly NavigationTrigger[]): void {\r\n    setNavigationTriggers(triggers);\r\n  }\r\n\r\n  /**\r\n   * Generates a URL for the route with the given name, optionally performing\r\n   * substitution of parameters.\r\n   *\r\n   * The route is searched in all the Router instances subscribed to\r\n   * navigation events.\r\n   *\r\n   * **Note:** For child route names, only array children are considered.\r\n   * It is not possible to generate URLs using a name for routes set with\r\n   * a children function.\r\n   *\r\n   * @param name - The route name or the route\u2019s `component` name.\r\n   * @param params - Optional object with route path parameters.\r\n   * Named parameters are passed by name (`params[name] = value`), unnamed\r\n   * parameters are passed by index (`params[index] = value`).\r\n   */\r\n  urlForName(name: string, params?: Params | null): string {\r\n    if (!this.#urlForName) {\r\n      this.#urlForName = generateUrls(this, {\r\n        cacheKeyProvider(route): string | undefined {\r\n          return 'component' in route && typeof route.component === 'string'\r\n            ? (route as Readonly<{ component: string }>).component\r\n            : undefined;\r\n        },\r\n      });\r\n    }\r\n    return getPathnameForRouter(this.#urlForName(name, params ?? undefined), this);\r\n  }\r\n\r\n  /**\r\n   * Generates a URL for the given route path, optionally performing\r\n   * substitution of parameters.\r\n   *\r\n   * @param path - String route path declared in [express.js\r\n   * syntax](https://expressjs.com/en/guide/routing.html#route-paths).\r\n   * @param params - Optional object with route path parameters.\r\n   * Named parameters are passed by name (`params[name] = value`), unnamed\r\n   * parameters are passed by index (`params[index] = value`).\r\n   */\r\n  urlForPath(path: string, params?: Params | null): string {\r\n    return getPathnameForRouter(\r\n      compile(path)((params as Partial<Record<string, string | string[]>> | null) ?? undefined),\r\n      this,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Triggers navigation to a new path. Returns a boolean without waiting until\r\n   * the navigation is complete. Returns `true` if at least one `Router`\r\n   * has handled the navigation (was subscribed and had `baseUrl` matching\r\n   * the `path` argument), otherwise returns `false`.\r\n   *\r\n   * @param path - A new in-app path string, or an URL-like object with\r\n   * `pathname` string property, and optional `search` and `hash` string\r\n   * properties.\r\n   */\r\n  static go(path: string | ResolveContext): boolean {\r\n    const { pathname, search, hash } = isString(path)\r\n      ? new URL(path, 'http://a') // some base to omit origin\r\n      : path;\r\n    return fireRouterEvent('go', { pathname, search, hash });\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["nextContext"]
}
