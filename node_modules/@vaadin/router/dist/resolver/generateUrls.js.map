{
  "version": 3,
  "sources": ["../../src/resolver/generateUrls.ts"],
  "sourcesContent": ["/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport { parse, type ParseOptions, type Token, tokensToFunction, type TokensToFunctionOptions } from 'path-to-regexp';\r\nimport type { EmptyObject, Writable } from 'type-fest';\r\nimport Resolver from './resolver.js';\r\nimport type { AnyObject, ChildrenCallback, IndexedParams, Params, Route } from './types.js';\r\nimport { getRoutePath, isString } from './utils.js';\r\n\r\nexport type UrlParams = Readonly<Record<string, ReadonlyArray<number | string> | number | string>>;\r\n\r\nfunction cacheRoutes<T, R extends AnyObject, C extends AnyObject>(\r\n  routesByName: Map<string, Array<Route<T, R, C>>>,\r\n  route: Route<T, R, C>,\r\n  routes?: ReadonlyArray<Route<T, R, C>> | ChildrenCallback<T, R, C>,\r\n  cacheKeyProvider?: (route: Route<T, R, C>) => string | undefined,\r\n): void {\r\n  const name = route.name ?? cacheKeyProvider?.(route);\r\n  if (name) {\r\n    if (routesByName.has(name)) {\r\n      routesByName.get(name)?.push(route);\r\n    } else {\r\n      routesByName.set(name, [route]);\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(routes)) {\r\n    for (const childRoute of routes) {\r\n      childRoute.parent = route;\r\n      cacheRoutes(routesByName, childRoute, childRoute.__children ?? childRoute.children, cacheKeyProvider);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getRouteByName<T, R extends AnyObject, C extends AnyObject>(\r\n  routesByName: Map<string, Array<Route<T, R, C>>>,\r\n  routeName: string,\r\n): Route<T, R, C> | undefined {\r\n  const routes = routesByName.get(routeName);\r\n\r\n  if (routes) {\r\n    if (routes.length > 1) {\r\n      throw new Error(`Duplicate route with name \"${routeName}\".` + ` Try seting unique 'name' route properties.`);\r\n    }\r\n\r\n    return routes[0];\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport type StringifyQueryParams = (params: UrlParams) => string;\r\n\r\nexport type GenerateUrlOptions<T, R extends AnyObject, C extends AnyObject> = ParseOptions &\r\n  Readonly<{\r\n    /**\r\n     * Add a query string to generated url based on unknown route params.\r\n     */\r\n    stringifyQueryParams?: StringifyQueryParams;\r\n    /**\r\n     * Generates a unique route name based on all parent routes with the specified separator.\r\n     */\r\n    uniqueRouteNameSep?: string;\r\n    cacheKeyProvider?(route: Route<T, R, C>): string | undefined;\r\n  }> &\r\n  TokensToFunctionOptions;\r\n\r\ntype RouteCacheRecord = Readonly<{\r\n  keys: Record<string, true>;\r\n  tokens: Token[];\r\n}>;\r\n\r\nexport type UrlGenerator = (routeName: string, params?: Params) => string;\r\n\r\nfunction generateUrls<T = unknown, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject>(\r\n  resolver: Resolver<T, R, C>,\r\n  options: GenerateUrlOptions<T, R, C> = {},\r\n): UrlGenerator {\r\n  if (!(resolver instanceof Resolver)) {\r\n    throw new TypeError('An instance of Resolver is expected');\r\n  }\r\n\r\n  const cache = new Map<string, RouteCacheRecord>();\r\n  const routesByName = new Map<string, Array<Route<T, R, C>>>();\r\n\r\n  return (routeName, params) => {\r\n    let route = getRouteByName(routesByName, routeName);\r\n    if (!route) {\r\n      routesByName.clear(); // clear cache\r\n      cacheRoutes(routesByName, resolver.root, resolver.root.__children, options.cacheKeyProvider);\r\n\r\n      route = getRouteByName(routesByName, routeName);\r\n      if (!route) {\r\n        throw new Error(`Route \"${routeName}\" not found`);\r\n      }\r\n    }\r\n\r\n    let cached: RouteCacheRecord | undefined = route.fullPath ? cache.get(route.fullPath) : undefined;\r\n    if (!cached) {\r\n      let fullPath = getRoutePath(route);\r\n      let rt = route.parent;\r\n      while (rt) {\r\n        const path = getRoutePath(rt);\r\n        if (path) {\r\n          fullPath = `${path.replace(/\\/$/u, '')}/${fullPath.replace(/^\\//u, '')}`;\r\n        }\r\n        rt = rt.parent;\r\n      }\r\n      const tokens = parse(fullPath);\r\n      const keys: Record<string, true> = Object.create(null);\r\n      for (const item of tokens) {\r\n        if (!isString(item)) {\r\n          keys[item.name] = true;\r\n        }\r\n      }\r\n      cached = { keys, tokens };\r\n      cache.set(fullPath, cached);\r\n      route.fullPath = fullPath;\r\n    }\r\n\r\n    const toPath = tokensToFunction(cached.tokens, { encode: encodeURIComponent, ...options });\r\n    let url = toPath(params) || '/';\r\n\r\n    if (options.stringifyQueryParams && params) {\r\n      const queryParams: Writable<IndexedParams> = {};\r\n      for (const [key, value] of Object.entries(params)) {\r\n        if (!(key in cached.keys) && value) {\r\n          queryParams[key] = value;\r\n        }\r\n      }\r\n      const query = options.stringifyQueryParams(queryParams as UrlParams);\r\n      if (query) {\r\n        url += query.startsWith('?') ? query : `?${query}`;\r\n      }\r\n    }\r\n\r\n    return url;\r\n  };\r\n}\r\n\r\nexport default generateUrls;\r\n"],
  "mappings": "AASA,SAAS,OAAsC,wBAAsD;AAErG,OAAO,cAAc;AAErB,SAAS,cAAc,gBAAgB;AAIvC,SAAS,YACP,cACA,OACA,QACA,kBACM;AACN,QAAM,OAAO,MAAM,QAAQ,mBAAmB,KAAK;AACnD,MAAI,MAAM;AACR,QAAI,aAAa,IAAI,IAAI,GAAG;AAC1B,mBAAa,IAAI,IAAI,GAAG,KAAK,KAAK;AAAA,IACpC,OAAO;AACL,mBAAa,IAAI,MAAM,CAAC,KAAK,CAAC;AAAA,IAChC;AAAA,EACF;AAEA,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,eAAW,cAAc,QAAQ;AAC/B,iBAAW,SAAS;AACpB,kBAAY,cAAc,YAAY,WAAW,cAAc,WAAW,UAAU,gBAAgB;AAAA,IACtG;AAAA,EACF;AACF;AAEA,SAAS,eACP,cACA,WAC4B;AAC5B,QAAM,SAAS,aAAa,IAAI,SAAS;AAEzC,MAAI,QAAQ;AACV,QAAI,OAAO,SAAS,GAAG;AACrB,YAAM,IAAI,MAAM,8BAA8B,SAAS,+CAAoD;AAAA,IAC7G;AAEA,WAAO,OAAO,CAAC;AAAA,EACjB;AAEA,SAAO;AACT;AAyBA,SAAS,aACP,UACA,UAAuC,CAAC,GAC1B;AACd,MAAI,EAAE,oBAAoB,WAAW;AACnC,UAAM,IAAI,UAAU,qCAAqC;AAAA,EAC3D;AAEA,QAAM,QAAQ,oBAAI,IAA8B;AAChD,QAAM,eAAe,oBAAI,IAAmC;AAE5D,SAAO,CAAC,WAAW,WAAW;AAC5B,QAAI,QAAQ,eAAe,cAAc,SAAS;AAClD,QAAI,CAAC,OAAO;AACV,mBAAa,MAAM;AACnB,kBAAY,cAAc,SAAS,MAAM,SAAS,KAAK,YAAY,QAAQ,gBAAgB;AAE3F,cAAQ,eAAe,cAAc,SAAS;AAC9C,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,UAAU,SAAS,aAAa;AAAA,MAClD;AAAA,IACF;AAEA,QAAI,SAAuC,MAAM,WAAW,MAAM,IAAI,MAAM,QAAQ,IAAI;AACxF,QAAI,CAAC,QAAQ;AACX,UAAI,WAAW,aAAa,KAAK;AACjC,UAAI,KAAK,MAAM;AACf,aAAO,IAAI;AACT,cAAM,OAAO,aAAa,EAAE;AAC5B,YAAI,MAAM;AACR,qBAAW,GAAG,KAAK,QAAQ,QAAQ,EAAE,CAAC,IAAI,SAAS,QAAQ,QAAQ,EAAE,CAAC;AAAA,QACxE;AACA,aAAK,GAAG;AAAA,MACV;AACA,YAAM,SAAS,MAAM,QAAQ;AAC7B,YAAM,OAA6B,uBAAO,OAAO,IAAI;AACrD,iBAAW,QAAQ,QAAQ;AACzB,YAAI,CAAC,SAAS,IAAI,GAAG;AACnB,eAAK,KAAK,IAAI,IAAI;AAAA,QACpB;AAAA,MACF;AACA,eAAS,EAAE,MAAM,OAAO;AACxB,YAAM,IAAI,UAAU,MAAM;AAC1B,YAAM,WAAW;AAAA,IACnB;AAEA,UAAM,SAAS,iBAAiB,OAAO,QAAQ,EAAE,QAAQ,oBAAoB,GAAG,QAAQ,CAAC;AACzF,QAAI,MAAM,OAAO,MAAM,KAAK;AAE5B,QAAI,QAAQ,wBAAwB,QAAQ;AAC1C,YAAM,cAAuC,CAAC;AAC9C,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,YAAI,EAAE,OAAO,OAAO,SAAS,OAAO;AAClC,sBAAY,GAAG,IAAI;AAAA,QACrB;AAAA,MACF;AACA,YAAM,QAAQ,QAAQ,qBAAqB,WAAwB;AACnE,UAAI,OAAO;AACT,eAAO,MAAM,WAAW,GAAG,IAAI,QAAQ,IAAI,KAAK;AAAA,MAClD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,uBAAQ;",
  "names": []
}
