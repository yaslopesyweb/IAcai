{
  "version": 3,
  "sources": ["../../src/resolver/resolver.ts"],
  "sourcesContent": ["/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\nimport type { EmptyObject } from 'type-fest';\r\nimport matchRoute, { type MatchWithRoute } from './matchRoute.js';\r\nimport defaultResolveRoute from './resolveRoute.js';\r\nimport type {\r\n  ActionResult,\r\n  AnyObject,\r\n  BasicRoutePart,\r\n  Match,\r\n  MaybePromise,\r\n  ResolveContext,\r\n  Route,\r\n  RouteContext,\r\n} from './types.js';\r\nimport { getNotFoundError, getRoutePath, isString, NotFoundError, notFoundResult, toArray } from './utils.js';\r\n\r\nfunction isDescendantRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  route?: Route<T, R, C>,\r\n  maybeParent?: Route<T, R, C>,\r\n) {\r\n  let _route = route;\r\n  while (_route) {\r\n    _route = _route.parent;\r\n    if (_route === maybeParent) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isRouteContext<T, R extends AnyObject, C extends AnyObject>(value: unknown): value is RouteContext<T, R, C> {\r\n  return (\r\n    !!value &&\r\n    typeof value === 'object' &&\r\n    'next' in value &&\r\n    'params' in value &&\r\n    'result' in value &&\r\n    'route' in value\r\n  );\r\n}\r\n\r\nexport interface ResolutionErrorOptions extends ErrorOptions {\r\n  code?: number;\r\n}\r\n\r\nexport class ResolutionError<T, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> extends Error {\r\n  readonly code?: number;\r\n  readonly context: RouteContext<T, R, C>;\r\n\r\n  constructor(context: RouteContext<T, R, C>, options?: ResolutionErrorOptions) {\r\n    let errorMessage = `Path '${context.pathname}' is not properly resolved due to an error.`;\r\n    const routePath = getRoutePath(context.route);\r\n    if (routePath) {\r\n      errorMessage += ` Resolution had failed on route: '${routePath}'`;\r\n    }\r\n    super(errorMessage, options);\r\n    this.code = options?.code;\r\n    this.context = context;\r\n  }\r\n\r\n  warn(): void {\r\n    console.warn(this.message);\r\n  }\r\n}\r\n\r\nfunction updateChainForRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<T, R, C>,\r\n  match: Match<T, R, C>,\r\n) {\r\n  const { path, route } = match;\r\n\r\n  if (route && !route.__synthetic) {\r\n    const item = { path, route };\r\n    if (route.parent && context.chain) {\r\n      for (let i = context.chain.length - 1; i >= 0; i--) {\r\n        if (context.chain[i].route === route.parent) {\r\n          break;\r\n        }\r\n\r\n        context.chain.pop();\r\n      }\r\n    }\r\n    context.chain?.push(item);\r\n  }\r\n}\r\n\r\nexport type ErrorHandlerCallback<T> = (error: unknown) => T;\r\n\r\nexport type ResolveRouteCallback<T, R extends AnyObject, C extends AnyObject> = (\r\n  context: RouteContext<T, R, C>,\r\n) => MaybePromise<ActionResult<T | RouteContext<T, R, C>>>;\r\n\r\nexport type ResolverOptions<T, R extends AnyObject, C extends AnyObject> = Readonly<{\r\n  baseUrl?: string;\r\n  context?: RouteContext<T, R, C>;\r\n  errorHandler?: ErrorHandlerCallback<T>;\r\n  resolveRoute?: ResolveRouteCallback<T, R, C>;\r\n}>;\r\n\r\nexport default class Resolver<T = unknown, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> {\r\n  /**\r\n   * The base URL for all routes in the router instance. By default,\r\n   * if the base element exists in the `<head>`, vaadin-router\r\n   * takes the `<base href>` attribute value, resolved against the current\r\n   * `document.URL`.\r\n   */\r\n  readonly baseUrl: string;\r\n  #context: RouteContext<T, R, C>;\r\n  readonly errorHandler?: ErrorHandlerCallback<T>;\r\n  readonly resolveRoute: ResolveRouteCallback<T, R, C>;\r\n  readonly #root: BasicRoutePart<T, R, C>;\r\n\r\n  constructor(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>, options?: ResolverOptions<T, R, C>);\r\n  constructor(\r\n    routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>,\r\n    { baseUrl = '', context, errorHandler, resolveRoute = defaultResolveRoute }: ResolverOptions<T, R, C> = {},\r\n  ) {\r\n    if (Object(routes) !== routes) {\r\n      throw new TypeError('Invalid routes');\r\n    }\r\n\r\n    this.baseUrl = baseUrl;\r\n    this.errorHandler = errorHandler;\r\n    this.resolveRoute = resolveRoute;\r\n\r\n    if (Array.isArray(routes)) {\r\n      // @FIXME: We should have a route array instead of a single route object\r\n      // to avoid type clash because of a missing `R` part of a route.\r\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n      this.#root = {\r\n        __children: routes,\r\n        __synthetic: true,\r\n        action: () => undefined,\r\n        path: '',\r\n      };\r\n    } else {\r\n      this.#root = { ...routes, parent: undefined };\r\n    }\r\n\r\n    this.#context = {\r\n      ...context!,\r\n      hash: '',\r\n      // eslint-disable-next-line @typescript-eslint/require-await\r\n      async next() {\r\n        return notFoundResult;\r\n      },\r\n      params: {},\r\n      pathname: '',\r\n      resolver: this,\r\n      route: this.#root as Route<T, R, C>,\r\n      search: '',\r\n      chain: [],\r\n    };\r\n  }\r\n\r\n  get root(): Route<T, R, C> {\r\n    return this.#root as Route<T, R, C>;\r\n  }\r\n\r\n  get context(): RouteContext<T, R, C> {\r\n    return this.#context;\r\n  }\r\n\r\n  /**\r\n   * If the baseUrl property is set, transforms the baseUrl and returns the full\r\n   * actual `base` string for using in the `new URL(path, base);` and for\r\n   * prepernding the paths with. The returned base ends with a trailing slash.\r\n   *\r\n   * Otherwise, returns empty string.\r\n   */\r\n  protected get __effectiveBaseUrl(): string {\r\n    return this.baseUrl ? new URL(this.baseUrl, document.baseURI || document.URL).href.replace(/[^/]*$/u, '') : '';\r\n  }\r\n\r\n  /**\r\n   * Returns the current list of routes (as a shallow copy). Adding / removing\r\n   * routes to / from the returned array does not affect the routing config,\r\n   * but modifying the route objects does.\r\n   *\r\n   * @public\r\n   */\r\n  getRoutes(): ReadonlyArray<Route<T, R, C>> {\r\n    return [...(this.#root.__children ?? [])];\r\n  }\r\n\r\n  /**\r\n   * Removes all existing routes from the routing config.\r\n   *\r\n   * @public\r\n   */\r\n  removeRoutes(): void {\r\n    this.#root.__children = [];\r\n  }\r\n\r\n  /**\r\n   * Asynchronously resolves the given pathname, i.e. finds all routes matching\r\n   * the pathname and tries resolving them one after another in the order they\r\n   * are listed in the routes config until the first non-null result.\r\n   *\r\n   * Returns a promise that is fulfilled with the return value of an object that consists of the first\r\n   * route handler result that returns something other than `null` or `undefined` and context used to get this result.\r\n   *\r\n   * If no route handlers return a non-null result, or if no route matches the\r\n   * given pathname the returned promise is rejected with a 'page not found'\r\n   * `Error`.\r\n   *\r\n   * @param pathnameOrContext - the pathname to\r\n   *    resolve or a context object with a `pathname` property and other\r\n   *    properties to pass to the route resolver functions.\r\n   */\r\n  async resolve(pathnameOrContext: ResolveContext<C> | string): Promise<ActionResult<RouteContext<T, R, C>>> {\r\n    const self = this;\r\n    const context: RouteContext<T, R, C> = {\r\n      ...this.#context,\r\n      ...(isString(pathnameOrContext) ? { pathname: pathnameOrContext } : pathnameOrContext),\r\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n      next,\r\n    };\r\n    const match = matchRoute(\r\n      this.#root as Route<T, R, C>,\r\n      this.__normalizePathname(context.pathname) ?? context.pathname,\r\n      !!this.baseUrl,\r\n    );\r\n    const resolve = this.resolveRoute;\r\n    let matches: IteratorResult<MatchWithRoute<T, R, C>, undefined> | null = null;\r\n    let nextMatches: IteratorResult<MatchWithRoute<T, R, C>, undefined> | null = null;\r\n    let currentContext = context;\r\n\r\n    async function next(\r\n      resume: boolean = false,\r\n      parent: Route<T, R, C> | undefined = matches?.value?.route,\r\n      prevResult?: ActionResult<T | RouteContext<T, R, C>>,\r\n    ): Promise<ActionResult<RouteContext<T, R, C>>> {\r\n      const routeToSkip = prevResult === null ? matches?.value?.route : undefined;\r\n      matches = nextMatches ?? match.next(routeToSkip);\r\n      nextMatches = null;\r\n\r\n      if (!resume) {\r\n        if (!!matches.done || !isDescendantRoute(matches.value.route, parent)) {\r\n          nextMatches = matches;\r\n          return notFoundResult;\r\n        }\r\n      }\r\n\r\n      if (matches.done) {\r\n        throw getNotFoundError(context);\r\n      }\r\n\r\n      currentContext = {\r\n        ...context,\r\n        params: matches.value.params,\r\n        route: matches.value.route,\r\n        chain: currentContext.chain?.slice(),\r\n      };\r\n      updateChainForRoute(currentContext, matches.value);\r\n\r\n      const resolution = await resolve(currentContext);\r\n\r\n      if (resolution !== null && resolution !== undefined && resolution !== notFoundResult) {\r\n        currentContext.result = isRouteContext<T, R, C>(resolution) ? resolution.result : resolution;\r\n        self.#context = currentContext;\r\n        return currentContext;\r\n      }\r\n      return await next(resume, parent, resolution);\r\n    }\r\n\r\n    try {\r\n      return await next(true, this.#root as Route<T, R, C>);\r\n    } catch (error: unknown) {\r\n      const _error =\r\n        error instanceof NotFoundError\r\n          ? error\r\n          : new ResolutionError(currentContext as RouteContext<R>, { code: 500, cause: error });\r\n\r\n      if (this.errorHandler) {\r\n        currentContext.result = this.errorHandler(_error);\r\n        return currentContext;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the routing config (replacing the existing one).\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   *    (the array is shallow copied)\r\n   */\r\n  setRoutes(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>): void {\r\n    this.#root.__children = [...toArray(routes)];\r\n  }\r\n\r\n  /**\r\n   * If the baseUrl is set, matches the pathname with the router\u2019s baseUrl,\r\n   * and returns the local pathname with the baseUrl stripped out.\r\n   *\r\n   * If the pathname does not match the baseUrl, returns undefined.\r\n   *\r\n   * If the `baseUrl` is not set, returns the unmodified pathname argument.\r\n   */\r\n  protected __normalizePathname(pathname: string): string | undefined {\r\n    if (!this.baseUrl) {\r\n      // No base URL, no need to transform the pathname.\r\n      return pathname;\r\n    }\r\n\r\n    const base = this.__effectiveBaseUrl;\r\n    // Convert pathname to a valid URL constructor argument\r\n    const url = pathname.startsWith('/') ? new URL(base).origin + pathname : `./${pathname}`;\r\n    const normalizedUrl = new URL(url, base).href;\r\n    if (normalizedUrl.startsWith(base)) {\r\n      return normalizedUrl.slice(base.length);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Appends one or several routes to the routing config and returns the\r\n   * effective routing config after the operation.\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   *    (the array is shallow copied)\r\n   */\r\n  protected addRoutes(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>): ReadonlyArray<Route<T, R, C>> {\r\n    this.#root.__children = [...(this.#root.__children ?? []), ...toArray(routes)];\r\n    return this.getRoutes();\r\n  }\r\n}\r\n"],
  "mappings": "AASA,OAAO,oBAAyC;AAChD,OAAO,yBAAyB;AAWhC,SAAS,kBAAkB,cAAc,UAAU,eAAe,gBAAgB,eAAe;AAEjG,SAAS,kBACP,OACA,aACA;AACA,MAAI,SAAS;AACb,SAAO,QAAQ;AACb,aAAS,OAAO;AAChB,QAAI,WAAW,aAAa;AAC1B,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,eAA4D,OAAgD;AACnH,SACE,CAAC,CAAC,SACF,OAAO,UAAU,YACjB,UAAU,SACV,YAAY,SACZ,YAAY,SACZ,WAAW;AAEf;AAMO,MAAM,wBAAiG,MAAM;AAAA,EACzG;AAAA,EACA;AAAA,EAET,YAAY,SAAgC,SAAkC;AAC5E,QAAI,eAAe,SAAS,QAAQ,QAAQ;AAC5C,UAAM,YAAY,aAAa,QAAQ,KAAK;AAC5C,QAAI,WAAW;AACb,sBAAgB,qCAAqC,SAAS;AAAA,IAChE;AACA,UAAM,cAAc,OAAO;AAC3B,SAAK,OAAO,SAAS;AACrB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,OAAa;AACX,YAAQ,KAAK,KAAK,OAAO;AAAA,EAC3B;AACF;AAEA,SAAS,oBACP,SACA,OACA;AACA,QAAM,EAAE,MAAM,MAAM,IAAI;AAExB,MAAI,SAAS,CAAC,MAAM,aAAa;AAC/B,UAAM,OAAO,EAAE,MAAM,MAAM;AAC3B,QAAI,MAAM,UAAU,QAAQ,OAAO;AACjC,eAAS,IAAI,QAAQ,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,YAAI,QAAQ,MAAM,CAAC,EAAE,UAAU,MAAM,QAAQ;AAC3C;AAAA,QACF;AAEA,gBAAQ,MAAM,IAAI;AAAA,MACpB;AAAA,IACF;AACA,YAAQ,OAAO,KAAK,IAAI;AAAA,EAC1B;AACF;AAeA,MAAO,SAA0G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtG;AAAA,EACT;AAAA,EACS;AAAA,EACA;AAAA,EACA;AAAA,EAGT,YACE,QACA,EAAE,UAAU,IAAI,SAAS,cAAc,eAAe,oBAAoB,IAA8B,CAAC,GACzG;AACA,QAAI,OAAO,MAAM,MAAM,QAAQ;AAC7B,YAAM,IAAI,UAAU,gBAAgB;AAAA,IACtC;AAEA,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,eAAe;AAEpB,QAAI,MAAM,QAAQ,MAAM,GAAG;AAIzB,WAAK,QAAQ;AAAA,QACX,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,QAAQ,MAAM;AAAA,QACd,MAAM;AAAA,MACR;AAAA,IACF,OAAO;AACL,WAAK,QAAQ,EAAE,GAAG,QAAQ,QAAQ,OAAU;AAAA,IAC9C;AAEA,SAAK,WAAW;AAAA,MACd,GAAG;AAAA,MACH,MAAM;AAAA;AAAA,MAEN,MAAM,OAAO;AACX,eAAO;AAAA,MACT;AAAA,MACA,QAAQ,CAAC;AAAA,MACT,UAAU;AAAA,MACV,UAAU;AAAA,MACV,OAAO,KAAK;AAAA,MACZ,QAAQ;AAAA,MACR,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA,EAEA,IAAI,OAAuB;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,UAAiC;AACnC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAc,qBAA6B;AACzC,WAAO,KAAK,UAAU,IAAI,IAAI,KAAK,SAAS,SAAS,WAAW,SAAS,GAAG,EAAE,KAAK,QAAQ,WAAW,EAAE,IAAI;AAAA,EAC9G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAA2C;AACzC,WAAO,CAAC,GAAI,KAAK,MAAM,cAAc,CAAC,CAAE;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAqB;AACnB,SAAK,MAAM,aAAa,CAAC;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAM,QAAQ,mBAA6F;AACzG,UAAM,OAAO;AACb,UAAM,UAAiC;AAAA,MACrC,GAAG,KAAK;AAAA,MACR,GAAI,SAAS,iBAAiB,IAAI,EAAE,UAAU,kBAAkB,IAAI;AAAA;AAAA,MAEpE;AAAA,IACF;AACA,UAAM,QAAQ;AAAA,MACZ,KAAK;AAAA,MACL,KAAK,oBAAoB,QAAQ,QAAQ,KAAK,QAAQ;AAAA,MACtD,CAAC,CAAC,KAAK;AAAA,IACT;AACA,UAAM,UAAU,KAAK;AACrB,QAAI,UAAqE;AACzE,QAAI,cAAyE;AAC7E,QAAI,iBAAiB;AAErB,mBAAe,KACb,SAAkB,OAClB,SAAqC,SAAS,OAAO,OACrD,YAC8C;AAC9C,YAAM,cAAc,eAAe,OAAO,SAAS,OAAO,QAAQ;AAClE,gBAAU,eAAe,MAAM,KAAK,WAAW;AAC/C,oBAAc;AAEd,UAAI,CAAC,QAAQ;AACX,YAAI,CAAC,CAAC,QAAQ,QAAQ,CAAC,kBAAkB,QAAQ,MAAM,OAAO,MAAM,GAAG;AACrE,wBAAc;AACd,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,QAAQ,MAAM;AAChB,cAAM,iBAAiB,OAAO;AAAA,MAChC;AAEA,uBAAiB;AAAA,QACf,GAAG;AAAA,QACH,QAAQ,QAAQ,MAAM;AAAA,QACtB,OAAO,QAAQ,MAAM;AAAA,QACrB,OAAO,eAAe,OAAO,MAAM;AAAA,MACrC;AACA,0BAAoB,gBAAgB,QAAQ,KAAK;AAEjD,YAAM,aAAa,MAAM,QAAQ,cAAc;AAE/C,UAAI,eAAe,QAAQ,eAAe,UAAa,eAAe,gBAAgB;AACpF,uBAAe,SAAS,eAAwB,UAAU,IAAI,WAAW,SAAS;AAClF,aAAK,WAAW;AAChB,eAAO;AAAA,MACT;AACA,aAAO,MAAM,KAAK,QAAQ,QAAQ,UAAU;AAAA,IAC9C;AAEA,QAAI;AACF,aAAO,MAAM,KAAK,MAAM,KAAK,KAAuB;AAAA,IACtD,SAAS,OAAgB;AACvB,YAAM,SACJ,iBAAiB,gBACb,QACA,IAAI,gBAAgB,gBAAmC,EAAE,MAAM,KAAK,OAAO,MAAM,CAAC;AAExF,UAAI,KAAK,cAAc;AACrB,uBAAe,SAAS,KAAK,aAAa,MAAM;AAChD,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,QAA8D;AACtE,SAAK,MAAM,aAAa,CAAC,GAAG,QAAQ,MAAM,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUU,oBAAoB,UAAsC;AAClE,QAAI,CAAC,KAAK,SAAS;AAEjB,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,KAAK;AAElB,UAAM,MAAM,SAAS,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI,EAAE,SAAS,WAAW,KAAK,QAAQ;AACtF,UAAM,gBAAgB,IAAI,IAAI,KAAK,IAAI,EAAE;AACzC,QAAI,cAAc,WAAW,IAAI,GAAG;AAClC,aAAO,cAAc,MAAM,KAAK,MAAM;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,UAAU,QAAuF;AACzG,SAAK,MAAM,aAAa,CAAC,GAAI,KAAK,MAAM,cAAc,CAAC,GAAI,GAAG,QAAQ,MAAM,CAAC;AAC7E,WAAO,KAAK,UAAU;AAAA,EACxB;AACF;",
  "names": []
}
