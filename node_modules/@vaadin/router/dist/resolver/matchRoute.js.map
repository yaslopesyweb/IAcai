{
  "version": 3,
  "sources": ["../../src/resolver/matchRoute.ts"],
  "sourcesContent": ["/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport type { Key } from 'path-to-regexp';\r\nimport matchPath, { type Match } from './matchPath.js';\r\nimport type { AnyObject, IndexedParams, Route } from './types.js';\r\nimport { getRoutePath, unwrapChildren } from './utils.js';\r\n\r\nexport type MatchWithRoute<T, R extends AnyObject, C extends AnyObject> = Match &\r\n  Readonly<{\r\n    route: Route<T, R, C>;\r\n  }>;\r\n\r\ntype RouteMatchIterator<T, R extends AnyObject, C extends AnyObject> = Iterator<\r\n  MatchWithRoute<T, R, C>,\r\n  undefined,\r\n  Route<T, R, C> | undefined\r\n>;\r\n\r\n/**\r\n * Traverses the routes tree and matches its nodes to the given pathname from\r\n * the root down to the leaves. Each match consumes a part of the pathname and\r\n * the matching process continues for as long as there is a matching child\r\n * route for the remaining part of the pathname.\r\n *\r\n * The returned value is a lazily evaluated iterator.\r\n *\r\n * The leading \"/\" in a route path matters only for the root of the routes\r\n * tree (or if all parent routes are \"\"). In all other cases a leading \"/\" in\r\n * a child route path has no significance.\r\n *\r\n * The trailing \"/\" in a _route path_ matters only for the leaves of the\r\n * routes tree. A leaf route with a trailing \"/\" matches only a pathname that\r\n * also has a trailing \"/\".\r\n *\r\n * The trailing \"/\" in a route path does not affect matching of child routes\r\n * in any way.\r\n *\r\n * The trailing \"/\" in a _pathname_ generally does not matter (except for\r\n * the case of leaf nodes described above).\r\n *\r\n * The \"\" and \"/\" routes have special treatment:\r\n *  1. as a single route\r\n *     the \"\" and \"/\" routes match only the \"\" and \"/\" pathnames respectively\r\n *  2. as a parent in the routes tree\r\n *     the \"\" route matches any pathname without consuming any part of it\r\n *     the \"/\" route matches any absolute pathname consuming its leading \"/\"\r\n *  3. as a leaf in the routes tree\r\n *     the \"\" and \"/\" routes match only if the entire pathname is consumed by\r\n *         the parent routes chain. In this case \"\" and \"/\" are equivalent.\r\n *  4. several directly nested \"\" or \"/\" routes\r\n *     - directly nested \"\" or \"/\" routes are 'squashed' (i.e. nesting two\r\n *       \"/\" routes does not require a double \"/\" in the pathname to match)\r\n *     - if there are only \"\" in the parent routes chain, no part of the\r\n *       pathname is consumed, and the leading \"/\" in the child routes' paths\r\n *       remains significant\r\n *\r\n * Side effect:\r\n *   - the routes tree `{ path: '' }` matches only the '' pathname\r\n *   - the routes tree `{ path: '', children: [ { path: '' } ] }` matches any\r\n *     pathname (for the tree root)\r\n *\r\n * Prefix matching can be enabled also by `children: true`.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/max-params\r\nfunction matchRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  route: Route<T, R, C>,\r\n  pathname: string,\r\n  ignoreLeadingSlash?: boolean,\r\n  parentKeys?: readonly Key[],\r\n  parentParams?: IndexedParams,\r\n): Iterator<MatchWithRoute<T, R, C>, undefined, Route<T, R, C> | undefined> {\r\n  let match: Match | null;\r\n  let childMatches: RouteMatchIterator<T, R, C> | null;\r\n  let childIndex = 0;\r\n  let routepath = getRoutePath(route);\r\n  if (routepath.startsWith('/')) {\r\n    if (ignoreLeadingSlash) {\r\n      routepath = routepath.substring(1);\r\n    }\r\n    // eslint-disable-next-line no-param-reassign\r\n    ignoreLeadingSlash = true;\r\n  }\r\n\r\n  return {\r\n    next(routeToSkip?: Route<T, R, C>): IteratorResult<MatchWithRoute<T, R, C>, undefined> {\r\n      if (route === routeToSkip) {\r\n        return { done: true, value: undefined };\r\n      }\r\n\r\n      route.__children ??= unwrapChildren(route.children);\r\n      const children = route.__children ?? [];\r\n      const exact = !route.__children && !route.children;\r\n\r\n      if (!match) {\r\n        match = matchPath(routepath, pathname, exact, parentKeys, parentParams);\r\n\r\n        if (match) {\r\n          return {\r\n            value: {\r\n              keys: match.keys,\r\n              params: match.params,\r\n              path: match.path,\r\n              route,\r\n            },\r\n          };\r\n        }\r\n      }\r\n\r\n      if (match && children.length > 0) {\r\n        while (childIndex < children.length) {\r\n          if (!childMatches) {\r\n            const childRoute = children[childIndex];\r\n            childRoute.parent = route;\r\n\r\n            let matchedLength = match.path.length;\r\n            if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {\r\n              matchedLength += 1;\r\n            }\r\n\r\n            childMatches = matchRoute(\r\n              childRoute,\r\n              pathname.substring(matchedLength),\r\n              ignoreLeadingSlash,\r\n              match.keys,\r\n              match.params,\r\n            );\r\n          }\r\n\r\n          const childMatch = childMatches.next(routeToSkip);\r\n          if (!childMatch.done) {\r\n            return {\r\n              done: false,\r\n              value: childMatch.value,\r\n            };\r\n          }\r\n\r\n          childMatches = null;\r\n          childIndex += 1;\r\n        }\r\n      }\r\n\r\n      return { done: true, value: undefined };\r\n    },\r\n  };\r\n}\r\n\r\nexport default matchRoute;\r\n"],
  "mappings": "AAUA,OAAO,mBAA+B;AAEtC,SAAS,cAAc,sBAAsB;AA2D7C,SAAS,WACP,OACA,UACA,oBACA,YACA,cAC0E;AAC1E,MAAI;AACJ,MAAI;AACJ,MAAI,aAAa;AACjB,MAAI,YAAY,aAAa,KAAK;AAClC,MAAI,UAAU,WAAW,GAAG,GAAG;AAC7B,QAAI,oBAAoB;AACtB,kBAAY,UAAU,UAAU,CAAC;AAAA,IACnC;AAEA,yBAAqB;AAAA,EACvB;AAEA,SAAO;AAAA,IACL,KAAK,aAAkF;AACrF,UAAI,UAAU,aAAa;AACzB,eAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,MACxC;AAEA,YAAM,eAAe,eAAe,MAAM,QAAQ;AAClD,YAAM,WAAW,MAAM,cAAc,CAAC;AACtC,YAAM,QAAQ,CAAC,MAAM,cAAc,CAAC,MAAM;AAE1C,UAAI,CAAC,OAAO;AACV,gBAAQ,UAAU,WAAW,UAAU,OAAO,YAAY,YAAY;AAEtE,YAAI,OAAO;AACT,iBAAO;AAAA,YACL,OAAO;AAAA,cACL,MAAM,MAAM;AAAA,cACZ,QAAQ,MAAM;AAAA,cACd,MAAM,MAAM;AAAA,cACZ;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS,SAAS,SAAS,GAAG;AAChC,eAAO,aAAa,SAAS,QAAQ;AACnC,cAAI,CAAC,cAAc;AACjB,kBAAM,aAAa,SAAS,UAAU;AACtC,uBAAW,SAAS;AAEpB,gBAAI,gBAAgB,MAAM,KAAK;AAC/B,gBAAI,gBAAgB,KAAK,SAAS,OAAO,aAAa,MAAM,KAAK;AAC/D,+BAAiB;AAAA,YACnB;AAEA,2BAAe;AAAA,cACb;AAAA,cACA,SAAS,UAAU,aAAa;AAAA,cAChC;AAAA,cACA,MAAM;AAAA,cACN,MAAM;AAAA,YACR;AAAA,UACF;AAEA,gBAAM,aAAa,aAAa,KAAK,WAAW;AAChD,cAAI,CAAC,WAAW,MAAM;AACpB,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,OAAO,WAAW;AAAA,YACpB;AAAA,UACF;AAEA,yBAAe;AACf,wBAAc;AAAA,QAChB;AAAA,MACF;AAEA,aAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,IACxC;AAAA,EACF;AACF;AAEA,IAAO,qBAAQ;",
  "names": []
}
