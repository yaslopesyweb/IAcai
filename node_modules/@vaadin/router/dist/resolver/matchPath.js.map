{
  "version": 3,
  "sources": ["../../src/resolver/matchPath.ts"],
  "sourcesContent": ["/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport { type Key, pathToRegexp } from 'path-to-regexp';\r\nimport type { Writable } from 'type-fest';\r\nimport type { IndexedParams } from '../types.js';\r\nimport { resolvePath } from './utils.js';\r\n\r\nexport interface RegExpExecOptArray extends ReadonlyArray<string | undefined> {\r\n  0: string;\r\n  index: number;\r\n  input: string;\r\n}\r\n\r\ntype Matcher = Readonly<{\r\n  keys: readonly Key[];\r\n  pattern: RegExp;\r\n}>;\r\n\r\nexport type Match = Readonly<{\r\n  keys: readonly Key[];\r\n  params: IndexedParams;\r\n  path: string;\r\n}>;\r\n\r\nconst cache = new Map<string, Matcher>();\r\n// see https://github.com/pillarjs/path-to-regexp/issues/148\r\ncache.set('|false', {\r\n  keys: [],\r\n  pattern: /(?:)/u,\r\n});\r\n\r\nfunction decodeParam(val: string): string {\r\n  try {\r\n    return decodeURIComponent(val);\r\n  } catch {\r\n    return val;\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/max-params\r\nfunction matchPath(\r\n  routePath: string,\r\n  path?: string[] | string,\r\n  exact: boolean = false,\r\n  parentKeys: readonly Key[] = [],\r\n  parentParams?: IndexedParams,\r\n): Match | null {\r\n  const cacheKey = `${routePath}|${String(exact)}`;\r\n  const _path = resolvePath(path);\r\n  let regexp = cache.get(cacheKey);\r\n\r\n  if (!regexp) {\r\n    const keys: Key[] = [];\r\n    regexp = {\r\n      keys,\r\n      pattern: pathToRegexp(routePath, keys, {\r\n        end: exact,\r\n        strict: routePath === '',\r\n      }),\r\n    };\r\n    cache.set(cacheKey, regexp);\r\n  }\r\n\r\n  const m: RegExpExecOptArray | null = regexp.pattern.exec(_path);\r\n  if (!m) {\r\n    return null;\r\n  }\r\n\r\n  const params: Writable<IndexedParams> = { ...parentParams };\r\n\r\n  for (let i = 1; i < m.length; i++) {\r\n    const key = regexp.keys[i - 1];\r\n    const prop = key.name;\r\n    const value = m[i];\r\n    if (value !== undefined || !Object.hasOwn(params, prop)) {\r\n      if (key.modifier === '+' || key.modifier === '*') {\r\n        // by default, as of path-to-regexp 6.0.0, the default delimiters\r\n        // are `/`, `#` and `?`.\r\n        params[prop] = value ? value.split(/[/?#]/u).map(decodeParam) : [];\r\n      } else {\r\n        params[prop] = value ? decodeParam(value) : value!;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    keys: [...parentKeys, ...regexp.keys],\r\n    params,\r\n    path: m[0],\r\n  };\r\n}\r\n\r\nexport default matchPath;\r\n"],
  "mappings": "AASA,SAAmB,oBAAoB;AAGvC,SAAS,mBAAmB;AAmB5B,MAAM,QAAQ,oBAAI,IAAqB;AAEvC,MAAM,IAAI,UAAU;AAAA,EAClB,MAAM,CAAC;AAAA,EACP,SAAS;AACX,CAAC;AAED,SAAS,YAAY,KAAqB;AACxC,MAAI;AACF,WAAO,mBAAmB,GAAG;AAAA,EAC/B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAGA,SAAS,UACP,WACA,MACA,QAAiB,OACjB,aAA6B,CAAC,GAC9B,cACc;AACd,QAAM,WAAW,GAAG,SAAS,IAAI,OAAO,KAAK,CAAC;AAC9C,QAAM,QAAQ,YAAY,IAAI;AAC9B,MAAI,SAAS,MAAM,IAAI,QAAQ;AAE/B,MAAI,CAAC,QAAQ;AACX,UAAM,OAAc,CAAC;AACrB,aAAS;AAAA,MACP;AAAA,MACA,SAAS,aAAa,WAAW,MAAM;AAAA,QACrC,KAAK;AAAA,QACL,QAAQ,cAAc;AAAA,MACxB,CAAC;AAAA,IACH;AACA,UAAM,IAAI,UAAU,MAAM;AAAA,EAC5B;AAEA,QAAM,IAA+B,OAAO,QAAQ,KAAK,KAAK;AAC9D,MAAI,CAAC,GAAG;AACN,WAAO;AAAA,EACT;AAEA,QAAM,SAAkC,EAAE,GAAG,aAAa;AAE1D,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,UAAM,MAAM,OAAO,KAAK,IAAI,CAAC;AAC7B,UAAM,OAAO,IAAI;AACjB,UAAM,QAAQ,EAAE,CAAC;AACjB,QAAI,UAAU,UAAa,CAAC,OAAO,OAAO,QAAQ,IAAI,GAAG;AACvD,UAAI,IAAI,aAAa,OAAO,IAAI,aAAa,KAAK;AAGhD,eAAO,IAAI,IAAI,QAAQ,MAAM,MAAM,QAAQ,EAAE,IAAI,WAAW,IAAI,CAAC;AAAA,MACnE,OAAO;AACL,eAAO,IAAI,IAAI,QAAQ,YAAY,KAAK,IAAI;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM,CAAC,GAAG,YAAY,GAAG,OAAO,IAAI;AAAA,IACpC;AAAA,IACA,MAAM,EAAE,CAAC;AAAA,EACX;AACF;AAEA,IAAO,oBAAQ;",
  "names": []
}
